
---
# PentesterLab - Análisis de Peticiones Web

Este documento describe una serie de comandos usados en un ejercicio típico de reconocimiento web. Analizamos tres comandos fundamentales: `dig` y dos variantes de `curl`, explicando su propósito y funcionamiento.

---

## 1. `dig hackycorp.com`

### Acción:
```bash
dig hackycorp.com
````

### Explicación:

`dig` es una herramienta de línea de comandos para consultar servidores DNS. Se utiliza para **obtener la dirección IP asociada a un nombre de dominio**.

- `hackycorp.com`: es el nombre del dominio que queremos resolver.
    

Este comando nos muestra:

- La dirección IP del servidor web que aloja el dominio.
    
- Información adicional como el servidor autoritativo y el tiempo de vida (TTL) del registro.
    

### ¿Por qué se usa?

- Para saber **qué IP resuelve un dominio**.
    
- Es útil para descubrir la IP real de una web si se usa como virtual host, especialmente en ejercicios donde se ataca directamente la IP.
    

---

## 2. `curl https://51.158.147.132/ --insecure`

### Acción:

```bash
curl https://51.158.147.132/ --insecure
```

### Explicación:

`curl` es una herramienta para hacer peticiones HTTP desde consola.

- `https://51.158.147.132/`: hace una petición HTTPS directamente a una **IP** (no un dominio).
    
- `--insecure`: evita que `curl` rechace el certificado TLS por no coincidir con el nombre de dominio.
    

Los certificados TLS están ligados a nombres de dominio. Si accedemos por IP, el nombre no coincide y normalmente se rechaza la conexión. El flag `--insecure` permite **ignorar ese error** y aún así ver la respuesta del servidor.

### ¿Por qué se usa?

- Para verificar si un servicio HTTPS está activo **aunque el certificado sea inválido**.
    
- Es útil en pruebas donde no tenemos acceso al dominio (por ejemplo, si no tenemos DNS funcionando o queremos atacar por IP).
    

---

## 3. `curl http://hackycorp.com/ -v -H "Host: test"`

### Acción:

```bash
curl http://hackycorp.com/ -v -H "Host: test"
```

### Explicación:

Este comando hace una petición HTTP con una cabecera personalizada.

- `-v`: modo verboso. Muestra todo el tráfico HTTP, incluidas las cabeceras de solicitud y respuesta.
    
- `-H "Host: test"`: sobrescribe la cabecera `Host` con el valor `"test"`.
    

En servidores que alojan varios sitios (Virtual Hosts), el servidor determina **qué página mostrar según el valor de la cabecera `Host`**.

### ¿Por qué se usa?

- Para probar configuraciones de **virtual hosting**.
    
- Puede revelar contenido diferente o mal configurado si el servidor responde a nombres de host no esperados.
    
- También se puede usar en ataques de **Host Header Injection** o para descubrir subdominios internos.
    

---

## Resumen

|Comando|Propósito|
|---|---|
|`dig hackycorp.com`|Obtener la IP del dominio.|
|`curl https://[IP] --insecure`|Acceder a un sitio HTTPS por IP ignorando el error del certificado.|
|`curl -v -H "Host: test"`|Probar comportamiento del servidor ante un valor de cabecera `Host` personalizado.|

---

## 4. Ejercicio: Enumeración y análisis visual con Aquatone (PentesterLab)

Este ejercicio consiste en enumerar subdominios de una organización ficticia (`hackycorp.com`), descargar archivos de imagen (en este caso, un logo), y analizar visualmente los resultados para identificar pistas o claves.

---
### Paso 1: Generar una lista de subdominios

```bash
for i in `seq 0 150`; do
    printf "0x%02x.a.hackycorp.com\n" $i >> hosts.txt
done
````

#### ¿Qué hace este comando?

- `seq 0 150`: genera una secuencia de números del 0 al 150.
    
- `printf "0x%02x.a.hackycorp.com\n" $i`: convierte cada número a hexadecimal con formato de dos dígitos (`0x00`, `0x01`, ..., `0x96`) y lo concatena con el dominio `a.hackycorp.com`, generando así subdominios como:
    
    - `0x00.a.hackycorp.com`
        
    - `0x01.a.hackycorp.com`
        
    - ...
        
- `>> hosts.txt`: guarda cada subdominio generado en un archivo llamado `hosts.txt`.
    

---
### Paso 2: Descargar capturas de cada subdominio

```bash
for i in `cat hosts.txt`;
do
    curl $i/logo.png -o $i.png
done
```

#### ¿Qué hace este comando?

- `cat hosts.txt`: lee cada línea (subdominio) del archivo generado en el paso anterior.
    
- `curl $i/logo.png`: intenta descargar el archivo `logo.png` de cada subdominio.
    
- `-o $i.png`: guarda el archivo como `0x00.a.hackycorp.com.png`, `0x01.a.hackycorp.com.png`, etc., para facilitar la revisión posterior.
    

---
### Paso 3: Visualizar los resultados

```bash
open .
```

#### ¿Qué hace este comando?

> `open .`: abre el directorio actual en el gestor de archivos gráfico de tu sistema operativo. Esto permite inspeccionar rápidamente las capturas descargadas.

- Este comando es específico de macOS. En Linux podrías usar `xdg-open .` o `nautilus .` dependiendo del entorno de escritorio.

---
## Objetivo

Revisar visualmente las capturas descargadas (`logo.png` de cada subdominio) para encontrar una pista visual que permita avanzar en el ejercicio (por ejemplo, una imagen con una clave, número o información única).

---
## Herramienta mencionada: Aquatone (opcional)

Aunque el título del ejercicio menciona **Aquatone**, esta herramienta no se ha usado directamente en los comandos anteriores. Aquatone normalmente se emplea para:

- Tomar capturas automáticas de subdominios activos.
    
- Generar un informe visual en HTML.
    
### Alternativa con Aquatone (por si quieres usarlo en otro ejercicio):

```bash
cat hosts.txt | aquatone
```

Esto generaría un informe visual automático de los subdominios listados.

---
## Conclusión

Este ejercicio combina técnicas de **enumeración de subdominios**, **descarga de contenido** y **análisis visual**. Es útil para identificar elementos únicos entre múltiples servidores, como una imagen que contiene una clave o una pista relevante.

---

## 5. Fuerza bruta descubrimiento de host manipulando el encabezado `Host`

```bash
ffuf -w /path/to/vhost/wordlist -u https://target -H "Host: FUZZ" -fs 4242
```

Acción:

```bash
curl https://hackycorp.com -H 'Host: random123.hackycorp.com'
```

Resultado:

```bash
<h1>Well done! You solved recon_07</h1>

The key for this exercise is 23eafa56-6d55-4b78-8307-24e7dc2ce5e6
```

Explicación: al enviar un encabezado *Host* diferente se nos muestra una respuesta, peor no es la que necesitamos por lo que usaremos *fuff* para descubrir nuevas respuestas

Acción:

```bash
ffuf -w /usr/share/wordlists/wfuzz/general/common.txt -u https://hackycorp.com -H "Host: FUZZ.hackycorp.com" -fr recon_07
```

Resultado:

```bash

admin                   [Status: 200, Size: 108, Words: 12, Lines: 4, Duration: 45ms]
Admin                   [Status: 200, Size: 108, Words: 12, Lines: 4, Duration: 60ms]
www                     [Status: 200, Size: 16011, Words: 5888, Lines: 278, Duration: 45ms]
:: Progress: [951/951] :: Job [1/1] :: 865 req/sec :: Duration: [0:00:01] :: Errors: 0 ::
```

Explicación: parece que hemos encontrado las rutas 'admin' y 'www', probémoslas con Curl de nuevo

Acción:

```bash
curl https://hackycorp.com -H 'Host: admin.hackycorp.com'
```

Resultado:

```bash
<h1>Well done! You solved recon_11 </h1>

The key for this exercise is e4599fa9-1cc4-4916-a394-ce455a954d86
```

---
## Paso 6: Transferencia de Zona (Zone Transfer)

### ¿Qué es una transferencia de zona?

Una **transferencia de zona** (en inglés *Zone Transfer*) es una operación DNS que permite replicar la base de datos de un servidor DNS primario a uno secundario. Su función original es **sincronizar los registros DNS entre servidores autorizados**.

Sin embargo, si esta funcionalidad no está correctamente restringida, un atacante puede aprovecharla para **obtener todos los registros del dominio**, revelando información sensible como:

- Subdominios ocultos
- Direcciones IP internas o externas
- Entradas TXT con claves o identificadores

Por este motivo, **normalmente está desactivada**, y poder ejecutarla con éxito indica un fallo de configuración en el servidor DNS.

---

### 1. Intento inicial de transferencia de zona

```bash
dig AXFR z.hackycorp.com
````

o alternativamente:


```bash
dig AXFR @<IP>
```


**Explicación**:  Aquí usamos `dig` para intentar una transferencia de zona completa del dominio `z.hackycorp.com` utilizando la opción `AXFR` (Asynchronous Full Zone Transfer).

Este comando, por defecto, intenta contactar al servidor DNS configurado en el sistema (por ejemplo, tu router o el servidor DNS de tu ISP).

---

### 2. Verificación del registro SOA

```bash
dig -t SOA z.hackycorp.com
```

**Explicación**:  
Antes de realizar una transferencia, es útil consultar el registro **SOA (Start of Authority)** del dominio. Este registro nos indica cuál es el servidor **autoridad primaria** para el dominio.

**Resultado**:

```bash
z.hackycorp.com. 604800 IN SOA ns1.hackycorp.com. ns1.hackycorp.com. ...
```

Esto nos muestra que `ns1.hackycorp.com` es el servidor responsable de manejar las peticiones DNS para `z.hackycorp.com`.

---

### 3. Transferencia de zona con servidor DNS explícito

```bash
dig AXFR z.hackycorp.com @z.hackycorp.com
```

**¿Por qué usamos `@z.hackycorp.com`?**

- El símbolo `@` en el comando `dig` **especifica el servidor DNS al que queremos consultar**.
    
- En este caso, en lugar de preguntar al DNS del sistema, le estamos pidiendo directamente al servidor de nombres del dominio (es decir, `z.hackycorp.com`).
    
- Esto es especialmente útil si el servidor autoritativo **sí permite la transferencia**, pero los DNS intermediarios no.
    

**Resultado exitoso**:

```bash
key.z.hackycorp.com.    IN  TXT "9f883f22-6ea5-4631-bbe8-95841ad63f56"
recon_14.z.hackycorp.com. IN TXT "e5fce970-6d94-43c1-bdd5-a06c2b235f9c"
...
```

Con esto obtenemos múltiples registros DNS del dominio, incluyendo posibles pistas o claves que se pueden usar en etapas posteriores del pentesting.

---

### Conclusión

La transferencia de zona es una técnica muy poderosa durante la fase de **reconocimiento activo** en un test de intrusión. Si está habilitada:

- Puede exponer **información interna valiosa**.
    
- Es un **fallo de configuración** que debe reportarse.
    

```txt
Consejo: Siempre especifica el servidor DNS con `@` para asegurarte de consultar directamente al servidor autoritativo.
```

---
## Paso 7: Consultar la versión del servidor DNS

### ¿Qué estamos haciendo?

Vamos a intentar **obtener la versión del software DNS** que está ejecutando el servidor `z.hackycorp.com`, usando una consulta especial al sistema de nombres.

---

Acción:

```bash
dig chaos txt VERSION.BIND @z.hackycorp.com
````

---

## Explicación detallada:

### ¿Qué es `VERSION.BIND`?

- `VERSION.BIND` es un **registro especial** disponible en algunos servidores BIND (Berkeley Internet Name Domain), que permite consultar la versión del software DNS que están usando.
    
- Esto puede ser útil para:
    
    - Identificar versiones vulnerables.
        
    - Realizar fingerprinting del servidor DNS.
        
    - Planificar posibles vectores de ataque si esa versión tiene fallos conocidos.
        

---

### ¿Qué significa `chaos`?

- Aquí no estamos usando la clase DNS estándar (`IN` para Internet), sino la clase **`CH` (Chaosnet), que es una clase especial.
    
- Los registros de tipo `CHAOS TXT` se usaban para depuración y pruebas.
    
- En este contexto, la clase `CHAOS` permite **consultar información interna** del servidor BIND, como la versión.
    

---

### ¿Qué hace `@z.hackycorp.com`?

- Le estamos diciendo a `dig` que **consulte directamente al servidor DNS del dominio `z.hackycorp.com`**, en lugar de usar un DNS cualquiera.
    
- Esto es útil si el servidor objetivo tiene configuraciones específicas que permiten este tipo de consultas.
    

---

Resultado:

```bash
; <<>> DiG 9.18.33-1~deb12u2-Debian <<>> chaos txt VERSION.BIND @z.hackycorp.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 17193
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: aaf137a97e4a16ce8d38127d681f88ef0cbf25cbf628f751 (good)
;; QUESTION SECTION:
;VERSION.BIND.			CH	TXT

;; ANSWER SECTION:
VERSION.BIND.		0	CH	TXT	"4e5e76e1-728a-49be-aea8-4591ba11e588"

;; AUTHORITY SECTION:
version.bind.		0	CH	NS	version.bind.

;; Query time: 66 msec
;; SERVER: 51.158.147.132#53(z.hackycorp.com) (UDP)
;; WHEN: Sat May 10 19:12:17 CEST 2025
;; MSG SIZE  rcvd: 144
```

- Esto indica que el servidor respondió con un valor, pero **no es una versión clásica de BIND como "BIND 9.16"**, sino un identificador tipo UUID.
    
- Muchas veces los administradores **modifican o ofuscan la respuesta** para evitar el fingerprinting, lo que parece ser el caso aquí.
    

---

## Conclusión:

Este tipo de consulta permite averiguar la versión del software BIND, pero:

- Si el servidor **responde con la versión real**, puede ser útil para buscar vulnerabilidades.
    
- Si devuelve un identificador raro o nada, es probable que el administrador **haya restringido o falseado la respuesta**, como medida de seguridad.
    


Consejo: Esta técnica forma parte del fingerprinting de servicios y puede ayudarte a ajustar tus vectores de ataque si conoces versiones vulnerables.

---
