
---

# DOM XSS con Web Messages y JSON.parse

## Introducción

En este laboratorio estudiamos una vulnerabilidad de **DOM-based XSS** que surge cuando una aplicación recibe mensajes mediante `postMessage`, los interpreta como objetos JSON usando `JSON.parse` y, en función de su contenido, modifica dinámicamente atributos sensibles del DOM.

En concreto, el mensaje recibido controla el atributo `src` de un `iframe` interno. Al no existir validación del origen del mensaje ni restricciones sobre el esquema de la URL, es posible inyectar una URL con esquema `javascript:` y lograr la **ejecución directa de código en el navegador de la víctima**.

[Ver laboratorio PortSwigger](https://portswigger.net/web-security/dom-based/controlling-the-web-message-source/lab-dom-xss-using-web-messages-and-json-parse)

## ¿En qué consiste esta vulnerabilidad?

La vulnerabilidad aparece por la combinación de varios factores inseguros:

1. La página escucha mensajes con `window.addEventListener('message', ...)`.
    
2. El contenido del mensaje se procesa con `JSON.parse` sin validar su procedencia.
    
3. Se confía plenamente en la estructura y valores del objeto JSON recibido.
    
4. Un campo del JSON controla directamente un sink peligroso (`iframe.src`).
    

El uso de JSON puede dar una falsa sensación de seguridad, pero **parsear JSON no implica validar ni sanear los datos**.

## Código vulnerable identificado

El fragmento relevante del código fuente es el siguiente:

```html
<script>
window.addEventListener('message', function(e) {
    var iframe = document.createElement('iframe'), ACMEplayer = {element: iframe}, d;
    document.body.appendChild(iframe);
    try {
        d = JSON.parse(e.data);
    } catch(e) {
        return;
    }
    switch(d.type) {
        case "page-load":
            ACMEplayer.element.scrollIntoView();
            break;
        case "load-channel":
            ACMEplayer.element.src = d.url;
            break;
        case "player-height-changed":
            ACMEplayer.element.style.width = d.width + "px";
            ACMEplayer.element.style.height = d.height + "px";
            break;
    }
}, false);
</script>
```

En este código observamos varios problemas críticos:

- No se valida `e.origin`.
    
- Se acepta cualquier mensaje que sea JSON válido.
    
- No se verifica el contenido del campo `url`.
    
- Se asigna directamente `d.url` al atributo `src` de un iframe.
    

## ¿Qué papel juega JSON.parse?

`JSON.parse()` convierte una cadena en formato JSON en un objeto JavaScript.

Es importante entender que:

- `JSON.parse` **solo valida la sintaxis**, no la seguridad del contenido.
    
- Si el JSON es válido, sus valores se consideran confiables en este código.
    
- No existe ningún control sobre tipos, esquemas o valores permitidos.
    

En este laboratorio, cualquier atacante puede construir un JSON perfectamente válido que contenga datos maliciosos.

## ¿Cómo se resuelve el laboratorio?

La explotación se realiza desde el servidor de explotación siguiendo estos pasos:

1. Cargamos la página vulnerable dentro de un `iframe`.
    
2. Al cargarse el `iframe`, enviamos un mensaje usando `postMessage()`.
    
3. El mensaje es una cadena JSON con un campo `type` y un campo `url`.
    
4. El `type` se establece en `load-channel`.
    
5. El listener interpreta el mensaje y entra en ese caso del `switch`.
    
6. El valor de `url` se asigna directamente a `iframe.src`.
    
7. El navegador ejecuta el esquema `javascript:`.
    

## Payload utilizado

El payload utilizado en el laboratorio es el siguiente:

```html
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/"
        onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>
</iframe>
```

Desglose del payload:

- El mensaje es un JSON válido.
    
- `type` fuerza la ejecución del caso `load-channel`.
    
- `url` contiene una URL con esquema `javascript:`.
    
- El comodín `'*'` permite enviar el mensaje desde cualquier origen.
    

## ¿Por qué funciona el ataque?

El ataque es efectivo porque:

- El código confía ciegamente en los datos recibidos por `postMessage`.
    
- No se valida el origen del mensaje.
    
- `iframe.src` acepta esquemas `javascript:`.
    
- `JSON.parse` no proporciona ningún mecanismo de seguridad adicional.
    

El navegador se limita a ejecutar lo que la aplicación le indica.

## Riesgos asociados

Una vulnerabilidad de este tipo puede permitir:

- Ejecución de JavaScript arbitrario.
    
- Robo de información accesible desde el DOM.
    
- Manipulación de la interfaz del usuario.
    
- Encadenamiento con otras vulnerabilidades del lado cliente.
    

Este tipo de fallos suele tener **impacto alto o crítico** en aplicaciones reales.

## Mitigaciones recomendadas

Para evitar este tipo de vulnerabilidades se recomienda:

- Validar siempre `event.origin`.
    
- Definir esquemas de URL permitidos explícitamente.
    
- Rechazar esquemas `javascript:` y similares.
    
- Evitar el uso directo de sinks sensibles con datos externos.
    
- No asumir que el uso de JSON implica seguridad.
    

Este laboratorio demuestra que **la estructura correcta de los datos no garantiza su seguridad**.

---
