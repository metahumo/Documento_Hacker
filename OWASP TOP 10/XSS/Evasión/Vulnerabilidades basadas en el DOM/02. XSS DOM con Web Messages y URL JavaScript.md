
---

# DOM XSS con Web Messages y URLs JavaScript

## Introducción

En este laboratorio analizamos una vulnerabilidad de **DOM-based XSS** que se manifiesta como una **redirección basada en Web Messages**. La aplicación escucha mensajes entrantes mediante `postMessage` y utiliza su contenido directamente como destino de navegación a través de `location.href`.

Aunque el código intenta validar que la URL comience por `http` o `https`, la comprobación está mal implementada. Esto nos permite inyectar una URL con esquema `javascript:` y lograr la **ejecución de código arbitrario en el navegador**.

El objetivo del laboratorio es comprender cómo una validación débil, combinada con un sink peligroso, puede derivar en un XSS DOM sin necesidad de inyección directa de HTML.

[Ver laboratorio PortSwigger](https://portswigger.net/web-security/dom-based/controlling-the-web-message-source/lab-dom-xss-using-web-messages-and-a-javascript-url)

## ¿En qué consiste esta vulnerabilidad?

La vulnerabilidad se basa en los siguientes elementos:

1. La página escucha mensajes usando `window.addEventListener('message', ...)`.
    
2. El contenido del mensaje (`e.data`) se trata como una URL de confianza.
    
3. Se intenta validar la URL comprobando si contiene las cadenas `http:` o `https:`.
    
4. Si la comprobación pasa, el valor se asigna directamente a `location.href`.
    

El fallo está en que **no se valida el esquema real de la URL**, sino únicamente la presencia de una subcadena. Esto permite que un payload malicioso incluya `http:` en cualquier parte del mensaje para superar el filtro.

## Código vulnerable identificado

El script relevante que encontramos en el código fuente es el siguiente:

```html
<script>
window.addEventListener('message', function(e) {
    var url = e.data;
    if (url.indexOf('http:') > -1 || url.indexOf('https:') > -1) {
        location.href = url;
    }
}, false);
</script>
```

Este código contiene varios problemas de seguridad:

- No se valida el origen del mensaje (`e.origin`).
    
- Se asume que el mensaje contiene una URL segura.
    
- La validación de la URL es superficial y fácilmente evadible.
    
- Se utiliza `location.href`, que es un sink capaz de ejecutar esquemas `javascript:`.
    

## ¿Qué es indexOf?

`indexOf()` es un método de JavaScript que devuelve la posición de la primera aparición de una subcadena dentro de otra cadena.

- Si la subcadena existe, devuelve un número mayor o igual a 0.
    
- Si no existe, devuelve `-1`.
    

Ejemplo:

```javascript
"javascript:print()//http://test".indexOf('http:')
```

En este caso, el resultado es un número positivo, porque la cadena contiene `http:` aunque **no sea el esquema principal de la URL**.

El error del laboratorio es asumir que la presencia de `http:` implica que la URL es segura, cuando en realidad el esquema ejecutado por el navegador es `javascript:`.

## ¿Cómo se resuelve el laboratorio?

El ataque se realiza desde el servidor de explotación siguiendo estos pasos:

1. Cargamos la página vulnerable dentro de un `iframe`.
    
2. Cuando el `iframe` termina de cargar, enviamos un mensaje con `postMessage()`.
    
3. El mensaje contiene una URL con esquema `javascript:` seguida de un comentario y una cadena que incluye `http:`.
    
4. La validación con `indexOf()` se cumple.
    
5. El valor se asigna a `location.href`.
    
6. El navegador ejecuta el JavaScript embebido en la URL.
    

## Payload utilizado

El payload utilizado en el laboratorio es el siguiente:

```html
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/"
        onload="this.contentWindow.postMessage('javascript:print()//http://prueba.com', '*')">
</iframe>
```

Desglose del payload:

- `javascript:print()` es el código que queremos ejecutar.
    
- `//` comenta el resto de la URL.
    
- `http://prueba.com` solo existe para satisfacer la validación basada en `indexOf()`.
    
- El `'*'` como `targetOrigin` permite enviar el mensaje sin restricciones.
    

## ¿Por qué funciona el ataque?

El ataque es efectivo porque:

- `location.href` ejecuta esquemas `javascript:`.
    
- La validación no comprueba el inicio de la URL ni su esquema real.
    
- `indexOf()` solo verifica la existencia de una cadena, no su contexto.
    
- `postMessage` permite comunicación entre orígenes por diseño.
    

El navegador no está rompiendo ninguna política de seguridad; simplemente ejecuta una instrucción peligrosa proporcionada por la aplicación.

## Riesgos asociados

Una vulnerabilidad de este tipo puede permitir:

- Ejecución de JavaScript arbitrario.
    
- Robo de información sensible accesible desde el DOM.
    
- Redirecciones maliciosas.
    
- Encadenamiento con otras vulnerabilidades del lado cliente.
    

En aplicaciones reales, este patrón suele tener **impacto crítico**.

## Mitigaciones recomendadas

Para evitar este tipo de fallos se recomienda:

- Validar estrictamente el esquema de la URL usando `URL()`.
    
- Permitir únicamente esquemas explícitos (`http` y `https`).
    
- Evitar el uso directo de `location.href` con datos externos.
    
- Validar siempre `event.origin`.
    
- No confiar en comprobaciones basadas en subcadenas.
    

Este laboratorio demuestra que una validación incorrecta puede ser tan peligrosa como no validar en absoluto.

---
