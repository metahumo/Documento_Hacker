
---

# CSRF con token validado según el método HTTP

## 1. Introducción

En este laboratorio trabajamos con un escenario de **Cross-Site Request Forgery (CSRF)** parcialmente protegido, en el que la aplicación implementa un mecanismo de defensa basado en tokens anti-CSRF, pero **solo lo aplica cuando la petición utiliza el método HTTP POST**.  
Si el mismo endpoint es accedido mediante **GET**, la validación del token se desactiva, lo que abre la puerta a la explotación.

Nuestro objetivo es cambiar el correo electrónico del usuario autenticado utilizando una petición GET maliciosa enviada desde una página controlada por el atacante.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-token-validation/lab-token-validation-depends-on-request-method)

---

## 2. Contexto de la vulnerabilidad

La funcionalidad legítima para actualizar el correo requiere:

- Endpoint `/my-account/change-email`
    
- Parámetro `email` con el valor nuevo
    
- Método HTTP **POST**
    
- Token `csrf` válido
    

Sin embargo, el mismo endpoint **acepta solicitudes GET** con parámetros en la URL, y en este contexto el servidor **no valida el token anti-CSRF**.

Esta inconsistencia origina una debilidad clara:

> La protección solo es efectiva en un método, pero el servidor no restringe qué métodos están permitidos para modificar el estado.

---

## 3. Técnica de explotación

La explotación consiste en:

1. Cambiar el método HTTP de POST a GET.
    
2. Enviar los parámetros en la URL.
    
3. Aprovechar que el servidor **no verifica el token en peticiones GET**.
    
4. Ejecutar la acción usando la sesión activa de la víctima.
    

Para hacerlo práctico, construimos un formulario HTML configurado para emitir una solicitud GET con los parámetros necesarios, y lo autoenviamos desde el navegador de la víctima.

---

## 4. Procedimiento paso a paso

### 4.1 Identificación del control de CSRF

1. Iniciamos sesión en la aplicación desde el navegador integrado de Burp.
    
2. Enviamos el formulario de cambio de correo.
    
3. Localizamos la petición en Burp Proxy.
    
4. Observamos que contiene un parámetro `csrf`.
    

---

### 4.2 Verificación del token

1. Enviamos la petición a Repeater.
    
2. Modificamos el valor del parámetro `csrf`.
    
3. Observamos que la petición es rechazada: la protección funciona cuando la solicitud es POST.
    

---

### 4.3 Cambio de método

1. En Repeater, usamos:
    
    **Right-click → Change request method → GET**
    
2. Observamos que el servidor **acepta la petición GET** incluso con token inválido o ausente.
    

Esto confirma que la validación depende del método.

---

## 5. Construcción del exploit

Para aprovechar esta debilidad, utilizamos un formulario GET alojado en el servidor de explotación:

```html
<form class="login-form" name="change-email-form" action="https://<host>/my-account/change-email" method="GET">
    <input type="hidden" name="email" value="pwned@hacked.com">
</form>

<script>
    document.forms[0].submit();
</script>
```

Puntos clave:

- No incluimos token `csrf`
    
- Usamos `method="GET"`
    
- El formulario se autoenvía
    
- La víctima solo tiene que visitar la página del exploit
    

---

## 6. Ejecución en el entorno del laboratorio

1. Abrimos el exploit server.
    
2. Pegamos el HTML del exploit en el campo **Body**.
    
3. Pulsamos **Store**.
    
4. Probamos el exploit con **View exploit**.
    
5. Confirmamos que el correo ha sido cambiado.
    

---

## 7. Finalización del laboratorio

Para completarlo:

1. Cambiamos el email a uno distinto del nuestro.
    
2. Guardamos el exploit.
    
3. Pulsamos **Deliver to victim**.
    

---

## 8. Análisis de impacto

Este laboratorio evidencia un fallo frecuente:

- Se valida el token solo en ciertos métodos.
    
- No se restringe qué métodos son permitidos en el endpoint.
    
- Métodos inseguros permiten modificar el estado.
    

Esto abre la puerta a ataques efectivos porque:

- Los navegadores envían cookies automáticamente.
    
- GET es trivial de disparar.
    
- No se requiere interacción de la víctima.
    

---

## 9. Conclusión

La protección anti-CSRF **no es efectiva si solo se aplica a algunos métodos HTTP**.  
Si el servidor permite múltiples métodos para modificar el estado, cada uno debe estar protegido.

Este laboratorio ejemplifica una defensa incompleta que, en términos prácticos, es equivalente a **no tener defensa**.

---

## 10. Lecturas recomendadas

- **OWASP: Cross-Site Request Forgery (CSRF)**  
    [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)
    
- **PortSwigger Web Security Academy: Cross-Site Request Forgery**  
    [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
    
- **OWASP Testing Guide – CSRF Testing**  
    [https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/01-Testing_for_CSRF](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/01-Testing_for_CSRF)
    
- **RFC 9110: HTTP Semantics** (métodos seguros e inseguros)  
    [https://www.rfc-editor.org/rfc/rfc9110](https://www.rfc-editor.org/rfc/rfc9110)
    

---
