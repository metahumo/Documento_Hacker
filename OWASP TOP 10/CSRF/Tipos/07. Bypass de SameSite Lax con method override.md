
---

# Bypass de SameSite Lax con method override

## 1. Introducción

Este laboratorio presenta una implementación vulnerable a CSRF a pesar de utilizar cookies con **SameSite=Lax** por defecto.  
Aprovechamos una propiedad de los navegadores (como Chrome) que permite el envío de cookies SameSite=Lax en **peticiones GET que implican una navegación de nivel superior**.

El backend solo acepta cambios de email mediante **POST**, pero implementa una característica peligrosa:  
acepta una petición GET con el parámetro `_method=POST` para tratarla como si fuese una petición POST legítima.

Esto nos permite construir un exploit que simplemente redirige a la víctima mediante `document.location` a una URL preparada, logrando el cambio de email sin interacción alguna.

[Ver laboratorio Portswigger](https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-lax-bypass-via-method-override)

---

## 2. Contexto de la vulnerabilidad

Los servidores web a veces implementan lo que se conoce como:

```
HTTP Method Override
```

Para permitir que clientes limitados puedan enviar operaciones tipo POST, PUT o DELETE, aunque solo soporten GET.

Esto se realiza mediante parámetros como:

```
_method=POST
_method=PUT
_method=DELETE
```

En este laboratorio ocurre que:

1. El cambio de email se realiza mediante POST
    
2. No existen tokens impredecibles
    
3. La cookie de sesión no define SameSite → se aplica `Lax` por defecto
    
4. SameSite=Lax permite envío de cookies en GET si implica navegación superior
    
5. El backend acepta overrides mediante `_method=POST`
    

Por tanto:

> Un GET con `_method=POST` y parámetros válidos se procesa como POST, mientras que el navegador envía la cookie de sesión.

---

## 3. Análisis de peticiones

### 3.1 Observación en Burp

Se identifica la petición legítima:

```
POST /my-account/change-email
email=<nuevo_email>
```

Y se confirma que **no hay token CSRF**.

### 3.2 Restricción SameSite

La cookie de sesión se establece sin atributos explícitos, así que el navegador aplica:

```
SameSite=Lax
```

Comportamiento relevante de SameSite Lax:

- En peticiones GET que **generan navegación de nivel superior**  
    → el navegador **sí envía la cookie**
    

Esto no ocurre en peticiones:

- IFRAME
    
- AJAX
    
- Fetch
    
- Imagen
    

Pero sí ocurre con:

- document.location
    
- window.location
    

### 3.3 Method override

Al convertir el POST a GET con Burp, el servidor lo rechaza.  
Sin embargo, al añadir:

```
_method=POST
```

El servidor lo acepta.

Ejemplo:

```
GET /my-account/change-email?email=foo@bar.com&_method=POST
```

Y responde 200 OK.

---

## 4. Explotación

La idea del ataque es:

1. Forzar una navegación GET a una URL del tipo:
    
    ```
    /my-account/change-email?email=...&_method=POST
    ```
    
2. El navegador envía automáticamente la cookie de sesión
    
3. El servidor trata la petición como POST
    
4. Ejecuta el cambio de email con éxito
    

Payload final utilizado:

```html
<script>
    location="https://0a01001d048e2003dce8088400e4007b.web-security-academy.net/my-account/change-email?email=pwned@pwned.com&_method=POST"
</script>
```

### ¿Qué ocurre aquí?

- El script fuerza navegación top-level
    
- Chrome envía la cookie SameSite=Lax
    
- El backend recibe:
    
    ```
    GET ...&_method=POST
    ```
    
- Internamente es tratado como si fuera:
    
    ```
    POST
    email=pwned@pwned.com
    ```
    
- El cambio de email se ejecuta
    

✔ Sin interacción del usuario  
✔ Sin ruptura directa de SameSite  
✔ Sin tokens CSRF  
✔ Sin AJAX

---

## 5. Publicación y verificación

En el exploit server:

1. Se almacena el payload
    
2. Se visualiza para comprobar el efecto
    
3. Se cambia el email víctima
    
4. Se “Deliver exploit to victim”
    

El laboratorio se completa si la cuenta víctima muestra el email reemplazado.

---

## 6. Fundamentación

Este ataque ilustra una interacción peligrosa entre:

```
SameSite=Lax + Method Override
```

SameSite reduce el envío de cookies en contextos cross-site, PERO:

- No lo bloquea en GET + navegación superior
    

Y el backend aprovecha GET con parámetros especiales para simular POST, lo cual:

- Destruye el modelo de seguridad esperado
    
- Convierte una navegación GET en una acción peligrosa
    
- Sin requerir interacción, tokens ni cabeceras especiales
    

En otras palabras:

> Una mitigación en el navegador es inútil si el servidor reinterpreta libremente la semántica del método.

---

## 7. Conclusión

Este laboratorio muestra que:

- SameSite Lax **no previene CSRF por sí solo**
    
- GET + navegación superior sigue enviando cookies
    
- Si el backend permite `_method=POST`, la aplicación puede ejecutar acciones sensibles en GET
    
- No se requiere token CSRF ni interacción
    

El atacante solo necesita:

- Un vector que fuerce navegación (script, meta refresh, etc.)
    
- Un endpoint que acepte method override
    

Y con eso tiene ejecución de acciones arbitrarias.

---

## 8. Mitigaciones

Para impedir estos ataques:

1. No aceptar method override en endpoints sensibles
    
2. Requerir tokens CSRF impredecibles
    
3. Verificar origen (Origin/Referer)
    
4. Establecer SameSite=Strict si es viable
    
5. Asociar acciones sensibles a POST reales
    
6. Rechazar parámetros `_method` en rutas críticas
    
7. Implementar protección de sesión por usuario y contexto
    

---

# Ejemplo de backend vulnerable

A modo ilustrativo, un backend podría implementar algo así:

```python
from flask import Flask, request, redirect

app = Flask(__name__)

@app.route("/my-account/change-email", methods=["GET", "POST"])
def change_email():
    # Si llega GET pero con override, interpretar como POST
    if request.method == "GET" and request.args.get("_method") == "POST":
        email = request.args.get("email")
        return apply_change(email)

    # Petición POST "legítima"
    if request.method == "POST":
        email = request.form.get("email")
        return apply_change(email)

    return "Method not allowed", 405


def apply_change(email):
    # Acción sensible sin tokens, sin validaciones
    # modificar email del usuario autenticado
    # ...
    return redirect("/my-account")
```

Características peligrosas:

- GET permite modificar estado si existe `_method=POST`
    
- No hay token CSRF
    
- No se valida origen
    
- El backend confía en cookies de sesión sin restricción adicional
    

Resultado:

> Un simple GET desde otro dominio que fuerce navegación puede ejecutar cambios críticos.

---

# Resumen conceptual clave

Este laboratorio demuestra que:

- SameSite Lax protege solo parcialmente
    
- GET + navegación superior **envía cookies**
    
- Method override puede subvertir el modelo de seguridad HTTP
    
- Si el backend acepta `_method=POST`, GET puede mutar estado
    

Combinando:

- Redirección forzada
    
- Method override
    
- Cookies SameSite=Lax
    

Es posible ejecutar acciones sensibles **sin interacción y sin tokens anti-CSRF**.

---