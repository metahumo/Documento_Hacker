
---

# Clickjacking con script anti-frame (frame buster)

## Introducción

En este laboratorio exploramos una variante de clickjacking en la que la aplicación víctima implementa un **script anti-frame**, también conocido como _frame buster_, cuyo propósito es impedir que la página pueda ser cargada dentro de un iframe. Aun así, el ataque sigue siendo posible si utilizamos correctamente el atributo **sandbox** del iframe, permitiendo únicamente la ejecución de formularios e impidiendo que el script de ruptura de marco se ejecute.

[Ver laboratorio PortSwigger](https://portswigger.net/web-security/clickjacking/lab-frame-buster-script)

## ¿Qué es un frame buster?

Un frame buster es un mecanismo defensivo muy común que intenta impedir que una página pueda ser incrustada en un iframe. Normalmente funciona comprobando si la ventana actual está siendo visualizada dentro de otra, por ejemplo comparando:

```
if (top != self) {
    // Página cargada dentro de un frame → bloquear
}
```

En este laboratorio se usa exactamente este tipo de verificación. Si detecta que está dentro de un iframe, registra un evento y cambia el contenido del `body` para mostrar un mensaje:

```javascript
if(top != self) {
    window.addEventListener("DOMContentLoaded", function() {
        document.body.innerHTML = 'This page cannot be framed';
    }, false);
}
```

El objetivo es impedir que la víctima interactúe con un formulario oculto, evitando ataques de clickjacking. Sin embargo, esta protección depende de que el script pueda acceder al contexto superior (`top`). Si lo deshabilitamos, la defensa deja de funcionar.

## ¿Qué es un iframe sandbox y por qué funciona aquí?

El atributo **sandbox** permite ejecutar un iframe con capacidades extremadamente limitadas.  
Por defecto, sandbox desactiva **scripts**, navegación, acceso al contexto superior, envío de formularios, etc.

Pero podemos habilitar selectivamente permisos concretos. En este laboratorio usamos:

```
sandbox="allow-forms"
```

Esto significa:

- Se permite que el formulario dentro del iframe se envíe.
    
- Pero **no** se permite ejecutar scripts, ni acceder a `window.top`, ni romper el frame.
    

Como el script anti-frame necesita ejecutar JavaScript y evaluar `top != self`, al estar sandbox bloqueando scripts y acceso al contexto superior, **el frame buster queda deshabilitado completamente**.  
Esto nos deja la página principal del laboratorio sin protección efectiva y lista para ser explotada mediante clickjacking.

## ¿En qué consiste el ataque?

1. La víctima está autenticada.
    
2. Visitamos nuestro exploit que contiene un botón señuelo con el texto _Click me_.
    
3. Debajo colocamos un iframe con el sandbox apropiado (`allow-forms`), lo que:
    
    - Evita que se ejecute el frame buster.
        
    - Permite el envío del formulario.
        
4. El parámetro GET `?email=pwned@pwned.com` precarga el nuevo email en el formulario real.
    
5. El iframe está alineado de forma transparente bajo el botón falso.
    
6. Cuando el usuario hace clic en _Click me_, envía el formulario real de cambio de email.
    
7. El correo queda modificado sin que la víctima sea consciente.
    

## Payload utilizado

Este es el HTML final utilizado para el ataque:

```html
<style> 
iframe {
    width: 1500px;
    height: 740px;
    opacity: 0.0001;
}

div {
    position: absolute;
    top: 490px;
    left: 215px;
}
</style>
<div>Click</div>
<iframe sandbox="allow-forms" src="https://0aa700330477d25681f6454e00ae002c.web-security-academy.net/my-account?email=pwned@pwned.com"></iframe>
```

Con esta estructura conseguimos:

- Anular el frame buster gracias al atributo `sandbox="allow-forms"`.
    
- Precargar el formulario con el nuevo email usando un parámetro GET.
    
- Colocar un señuelo como botón falso sobre el botón real.
    
- Hacer que la víctima pulse el botón legítimo del formulario sin darse cuenta.
    

## ¿Por qué es efectivo?

Este ataque funciona porque:

- El script anti-frame no puede ejecutarse dentro de un iframe sandboxed.
    
- El formulario legítimo sigue siendo accesible y funcional.
    
- El usuario realiza realmente la acción, así que no se rompe ningún token CSRF.
    
- El servidor recibe una petición auténtica del propio navegador de la víctima.
    

En resumen: **la defensa existe, pero el atacante ha neutralizado su ejecución aprovechando una configuración débil.**

## Riesgos asociados

Una vulnerabilidad de este tipo permite:

- Cambiar el correo y secuestrar cuentas.
    
- Forzar al usuario a interactuar con acciones sensibles sin saberlo.
    
- Evitar mecanismos defensivos mal implementados o dependientes de JavaScript.
    

## Mitigaciones recomendadas

Para evitar estos ataques, la aplicación debería implementar:

- `X-Frame-Options: DENY` o `SAMEORIGIN`.
    
- `Content-Security-Policy: frame-ancestors 'none';`.
    
- Evitar que parámetros GET precarguen datos sensibles.
    
- No depender solo de scripts anti-frame, ya que pueden ser deshabilitados.
    
- Usar confirmaciones explícitas al realizar cambios críticos.
    

---
